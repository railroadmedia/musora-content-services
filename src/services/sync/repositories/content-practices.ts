import SyncRepository from "./base";
import ContentPractice from "../models/ContentPractice";
import { RecordId } from "@nozbe/watermelondb";

export default class PracticeRepository extends SyncRepository<ContentPractice> {
  async trackAutoPractice(contentId: number, day: string, incrementalDurationSeconds: number, details: { instrument_id?: number } = {}) {
    return await this.upsertOne(PracticeRepository.generateAutoId(contentId, day), r => {
      r._raw.id = PracticeRepository.generateAutoId(contentId, day);
      r.auto = true;
      r.content_id = contentId;
      r.day = day;

      r.duration_seconds = Math.min((r.duration_seconds || 0) + incrementalDurationSeconds, 59999);

      if (details.instrument_id !== undefined) {
        // r.instrument_id = details.instrument_id;
      }
    })
  }

  async recordManualPractice(day: string, durationSeconds: number, details: {
    title: string | null;
  }) {
    return await this.insertOne((r) => {
      const manualId = r._raw.id; // yoink watermelon's autogenerated id
      r._raw.id = PracticeRepository.generateManualId(manualId);

      r.manual_id = manualId;
      r.auto = false;

      r.day = day;
      r.duration_seconds = Math.min(durationSeconds, 59999);

      r.title = details.title ?? null;
    });
  }

  async updateDetails(id: RecordId, details: {
    duration_seconds?: number;
    title?: string | null;
  }) {
    return await this.updateOneId(id, r => {
      Object.entries(details).forEach(([key, value]) => {
        if (value !== undefined) {
          (r as any)[key] = value;
        }
      });
    })
  }

  private static generateAutoId(contentId: number, day: string) {
    return ['auto', contentId.toString(), day].join(':');
  }

  private static generateManualId(manualId: string) {
    return `manual:${manualId}`;
  }
}
