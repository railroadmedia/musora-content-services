import SyncRepository from "./base";
import Practice from "../models/Practice";
import { RecordId } from "@nozbe/watermelondb";

export default class PracticesRepository extends SyncRepository<Practice> {
  async trackAutoPractice(contentId: number, day: string, incrementalDurationSeconds: number) {
    return await this.upsertOne(PracticesRepository.generateAutoId(contentId, day), r => {
      r._raw.id = PracticesRepository.generateAutoId(contentId, day);
      r.auto = true;
      r.content_id = contentId;
      r.day = day;

      r.duration_seconds = Math.min((r.duration_seconds || 0) + incrementalDurationSeconds, 59999);
    })
  }

  async recordManualPractice(day: string, durationSeconds: number, details: Partial<Pick<Practice, 'title' | 'instrument_id' | 'category_id' | 'thumbnail_url'>> = {}) {
    return await this.insertOne((r) => {
      const manualId = r._raw.id; // yoink watermelon's autogenerated id
      r._raw.id = PracticesRepository.generateManualId(manualId);

      r.manual_id = manualId;
      r.auto = false;

      r.day = day;
      r.duration_seconds = Math.min(durationSeconds, 59999);

      r.title = details.title ?? null;
      r.thumbnail_url = details.thumbnail_url ?? null;
      r.category_id = details.category_id ?? null;
      r.instrument_id = details.instrument_id ?? null;
    });
  }

  async updateDetails(id: RecordId, details: Partial<Pick<Practice, 'duration_seconds' | 'title' | 'thumbnail_url' | 'category_id' | 'instrument_id'>>) {
    return await this.updateOneId(id, r => {
      ['duration_seconds', 'title', 'thumbnail_url', 'category_id', 'instrument_id'].forEach(key => {
        const value = details[key as keyof typeof details];
        if (value !== undefined) {
          (r as any)[key] = value;
        }
      })
    })
  }

  private static generateAutoId(contentId: number, day: string) {
    return ['auto', contentId.toString(), day].join(':');
  }

  private static generateManualId(manualId: string) {
    return `manual:${manualId}`;
  }
}
