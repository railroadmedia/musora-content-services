<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>sanity.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Accounts.html">Accounts</a><ul class='methods'><li data-type='method'><a href="module-Accounts.html#~confirmEmailChange">confirmEmailChange</a></li><li data-type='method'><a href="module-Accounts.html#~requestEmailChange">requestEmailChange</a></li><li data-type='method'><a href="module-Accounts.html#~resetPassword">resetPassword</a></li><li data-type='method'><a href="module-Accounts.html#~sendAccountSetupEmail">sendAccountSetupEmail</a></li><li data-type='method'><a href="module-Accounts.html#~sendPasswordResetEmail">sendPasswordResetEmail</a></li><li data-type='method'><a href="module-Accounts.html#~setupAccount">setupAccount</a></li><li data-type='method'><a href="module-Accounts.html#~status">status</a></li></ul></li><li><a href="module-Awards.html">Awards</a><ul class='methods'><li data-type='method'><a href="module-Awards.html#~fetchAwardsForUser">fetchAwardsForUser</a></li><li data-type='method'><a href="module-Awards.html#~fetchCertificate">fetchCertificate</a></li></ul></li><li><a href="module-Categories.html">Categories</a><ul class='methods'><li data-type='method'><a href="module-Categories.html#~createForumCategory">createForumCategory</a></li><li data-type='method'><a href="module-Categories.html#~fetchForumCategories">fetchForumCategories</a></li><li data-type='method'><a href="module-Categories.html#~updateForumCategory">updateForumCategory</a></li></ul></li><li><a href="module-Config.html">Config</a><ul class='methods'><li data-type='method'><a href="module-Config.html#.initializeService">initializeService</a></li></ul></li><li><a href="module-Content-Services-V2.html">Content-Services-V2</a><ul class='methods'><li data-type='method'><a href="module-Content-Services-V2.html#.getContentRows">getContentRows</a></li><li data-type='method'><a href="module-Content-Services-V2.html#.getNewAndUpcoming">getNewAndUpcoming</a></li><li data-type='method'><a href="module-Content-Services-V2.html#.getRecent">getRecent</a></li><li data-type='method'><a href="module-Content-Services-V2.html#.getRecentForTab">getRecentForTab</a></li><li data-type='method'><a href="module-Content-Services-V2.html#.getRecommendedForYou">getRecommendedForYou</a></li><li data-type='method'><a href="module-Content-Services-V2.html#.getScheduleContentRows">getScheduleContentRows</a></li><li data-type='method'><a href="module-Content-Services-V2.html#.getTabResults">getTabResults</a></li></ul></li><li><a href="module-GuidedCourses.html">GuidedCourses</a></li><li><a href="module-Interests.html">Interests</a><ul class='methods'><li data-type='method'><a href="module-Interests.html#.fetchInterests">fetchInterests</a></li><li data-type='method'><a href="module-Interests.html#.fetchUninterests">fetchUninterests</a></li><li data-type='method'><a href="module-Interests.html#.markContentAsInterested">markContentAsInterested</a></li><li data-type='method'><a href="module-Interests.html#.markContentAsNotInterested">markContentAsNotInterested</a></li><li data-type='method'><a href="module-Interests.html#.removeContentAsInterested">removeContentAsInterested</a></li><li data-type='method'><a href="module-Interests.html#.removeContentAsNotInterested">removeContentAsNotInterested</a></li></ul></li><li><a href="module-Payments.html">Payments</a><ul class='methods'><li data-type='method'><a href="module-Payments.html#~fetchCustomerPayments">fetchCustomerPayments</a></li></ul></li><li><a href="module-Permissions.html">Permissions</a><ul class='methods'><li data-type='method'><a href="module-Permissions.html#.fetchUserPermissions">fetchUserPermissions</a></li><li data-type='method'><a href="module-Permissions.html#.reset">reset</a></li></ul></li><li><a href="module-Playlists.html">Playlists</a><ul class='methods'><li data-type='method'><a href="module-Playlists.html#.addItemToPlaylist">addItemToPlaylist</a></li><li data-type='method'><a href="module-Playlists.html#.createPlaylist">createPlaylist</a></li><li data-type='method'><a href="module-Playlists.html#.deletePlaylist">deletePlaylist</a></li><li data-type='method'><a href="module-Playlists.html#.duplicatePlaylist">duplicatePlaylist</a></li><li data-type='method'><a href="module-Playlists.html#.fetchPlaylist">fetchPlaylist</a></li><li data-type='method'><a href="module-Playlists.html#.fetchPlaylistItems">fetchPlaylistItems</a></li><li data-type='method'><a href="module-Playlists.html#.fetchUserPlaylists">fetchUserPlaylists</a></li><li data-type='method'><a href="module-Playlists.html#.togglePlaylistPrivate">togglePlaylistPrivate</a></li><li data-type='method'><a href="module-Playlists.html#.undeletePlaylist">undeletePlaylist</a></li><li data-type='method'><a href="module-Playlists.html#.updatePlaylist">updatePlaylist</a></li><li data-type='method'><a href="module-Playlists.html#~deleteItemsFromPlaylist">deleteItemsFromPlaylist</a></li><li data-type='method'><a href="module-Playlists.html#~likePlaylist">likePlaylist</a></li><li data-type='method'><a href="module-Playlists.html#~reportPlaylist">reportPlaylist</a></li><li data-type='method'><a href="module-Playlists.html#~restoreItemFromPlaylist">restoreItemFromPlaylist</a></li><li data-type='method'><a href="module-Playlists.html#~unlikePlaylist">unlikePlaylist</a></li></ul></li><li><a href="module-Railcontent-Services.html">Railcontent-Services</a><ul class='methods'><li data-type='method'><a href="module-Railcontent-Services.html#.assignModeratorToComment">assignModeratorToComment</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.closeComment">closeComment</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.createComment">createComment</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.deleteComment">deleteComment</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.editComment">editComment</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.fetchAllCompletedStates">fetchAllCompletedStates</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.fetchCarouselCardData">fetchCarouselCardData</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.fetchComment">fetchComment</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.fetchCommentRelies">fetchCommentRelies</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.fetchComments">fetchComments</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.fetchCompletedContent">fetchCompletedContent</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.fetchCompletedState">fetchCompletedState</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.fetchContentInProgress">fetchContentInProgress</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.fetchContentPageUserData">fetchContentPageUserData</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.fetchNextContentDataForParent">fetchNextContentDataForParent</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.fetchRecentUserActivities">fetchRecentUserActivities</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.fetchSongsInProgress">fetchSongsInProgress</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.fetchTopComment">fetchTopComment</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.fetchUserAward">fetchUserAward</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.fetchUserBadges">fetchUserBadges</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.fetchUserPracticeNotes">fetchUserPracticeNotes</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.likeComment">likeComment</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.openComment">openComment</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.postContentComplete">postContentComplete</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.postContentReset">postContentReset</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.postContentRestore">postContentRestore</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.postContentStart">postContentStart</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.replyToComment">replyToComment</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.reportComment">reportComment</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.restoreComment">restoreComment</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.setStudentViewForUser">setStudentViewForUser</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.unassignModeratorToComment">unassignModeratorToComment</a></li><li data-type='method'><a href="module-Railcontent-Services.html#.unlikeComment">unlikeComment</a></li><li data-type='method'><a href="module-Railcontent-Services.html#~fetchLastInteractedChild">fetchLastInteractedChild</a></li></ul></li><li><a href="module-Sanity-Services.html">Sanity-Services</a><ul class='methods'><li data-type='method'><a href="module-Sanity-Services.html#.fetchAll">fetchAll</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchAllFilterOptions">fetchAllFilterOptions</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchAllPacks">fetchAllPacks</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchArtistLessons">fetchArtistLessons</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchArtists">fetchArtists</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchByRailContentId">fetchByRailContentId</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchByRailContentIds">fetchByRailContentIds</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchByReference">fetchByReference</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchCoachLessons">fetchCoachLessons</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchComingSoon">fetchComingSoon</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchCommentModContentData">fetchCommentModContentData</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchFoundation">fetchFoundation</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchGenreLessons">fetchGenreLessons</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchLeaving">fetchLeaving</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchLessonContent">fetchLessonContent</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchLessonsFeaturingThisContent">fetchLessonsFeaturingThisContent</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchMetadata">fetchMetadata</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchMethod">fetchMethod</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchMethodChildren">fetchMethodChildren</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchMethodChildrenIds">fetchMethodChildrenIds</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchMethodPreviousNextLesson">fetchMethodPreviousNextLesson</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchNewReleases">fetchNewReleases</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchNextPreviousLesson">fetchNextPreviousLesson</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchOtherSongVersions">fetchOtherSongVersions</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchPackAll">fetchPackAll</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchPackData">fetchPackData</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchParentForDownload">fetchParentForDownload</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchRelatedLessons">fetchRelatedLessons</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchRelatedRecommendedContent">fetchRelatedRecommendedContent</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchRelatedSongs">fetchRelatedSongs</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchReturning">fetchReturning</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchSanity">fetchSanity</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchScheduledReleases">fetchScheduledReleases</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchShowsData">fetchShowsData</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchSiblingContent">fetchSiblingContent</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchSongArtistCount">fetchSongArtistCount</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchSongById">fetchSongById</a></li><li data-type='method'><a href="module-Sanity-Services.html#.fetchUpcomingEvents">fetchUpcomingEvents</a></li><li data-type='method'><a href="module-Sanity-Services.html#.jumpToContinueContent">jumpToContinueContent</a></li><li data-type='method'><a href="module-Sanity-Services.html#~fetchRelatedByLicense">fetchRelatedByLicense</a></li><li data-type='method'><a href="module-Sanity-Services.html#~getQueryFromPage">getQueryFromPage</a></li></ul></li><li><a href="module-Sessions.html">Sessions</a><ul class='methods'><li data-type='method'><a href="module-Sessions.html#.login">login</a></li><li data-type='method'><a href="module-Sessions.html#.logout">logout</a></li></ul></li><li><a href="module-Threads.html">Threads</a><ul class='methods'><li data-type='method'><a href="module-Threads.html#~createThread">createThread</a></li><li data-type='method'><a href="module-Threads.html#~pinThread">pinThread</a></li><li data-type='method'><a href="module-Threads.html#~unpinThread">unpinThread</a></li></ul></li><li><a href="module-UserActivity.html">UserActivity</a><ul class='methods'><li data-type='method'><a href="module-UserActivity.html#.calculateLongestStreaks">calculateLongestStreaks</a></li><li data-type='method'><a href="module-UserActivity.html#.createPracticeNotes">createPracticeNotes</a></li><li data-type='method'><a href="module-UserActivity.html#.deletePracticeSession">deletePracticeSession</a></li><li data-type='method'><a href="module-UserActivity.html#.deleteUserActivity">deleteUserActivity</a></li><li data-type='method'><a href="module-UserActivity.html#.getPracticeNotes">getPracticeNotes</a></li><li data-type='method'><a href="module-UserActivity.html#.getPracticeSessions">getPracticeSessions</a></li><li data-type='method'><a href="module-UserActivity.html#.getProgressRows">getProgressRows</a></li><li data-type='method'><a href="module-UserActivity.html#.getRecentActivity">getRecentActivity</a></li><li data-type='method'><a href="module-UserActivity.html#.getUserMonthlyStats">getUserMonthlyStats</a></li><li data-type='method'><a href="module-UserActivity.html#.getUserWeeklyStats">getUserWeeklyStats</a></li><li data-type='method'><a href="module-UserActivity.html#.pinProgressRow">pinProgressRow</a></li><li data-type='method'><a href="module-UserActivity.html#.recordUserActivity">recordUserActivity</a></li><li data-type='method'><a href="module-UserActivity.html#.recordUserPractice">recordUserPractice</a></li><li data-type='method'><a href="module-UserActivity.html#.removeUserPractice">removeUserPractice</a></li><li data-type='method'><a href="module-UserActivity.html#.restorePracticeSession">restorePracticeSession</a></li><li data-type='method'><a href="module-UserActivity.html#.restoreUserActivity">restoreUserActivity</a></li><li data-type='method'><a href="module-UserActivity.html#.restoreUserPractice">restoreUserPractice</a></li><li data-type='method'><a href="module-UserActivity.html#.unpinProgressRow">unpinProgressRow</a></li><li data-type='method'><a href="module-UserActivity.html#.updatePracticeNotes">updatePracticeNotes</a></li><li data-type='method'><a href="module-UserActivity.html#.updateUserPractice">updateUserPractice</a></li></ul></li><li><a href="module-UserChat.html">UserChat</a><ul class='methods'><li data-type='method'><a href="module-UserChat.html#.fetchChatSettings">fetchChatSettings</a></li></ul></li><li><a href="module-UserManagement.html">UserManagement</a><ul class='methods'><li data-type='method'><a href="module-UserManagement.html#.blockUser">blockUser</a></li><li data-type='method'><a href="module-UserManagement.html#.blockedUsers">blockedUsers</a></li><li data-type='method'><a href="module-UserManagement.html#.deletePicture">deletePicture</a></li><li data-type='method'><a href="module-UserManagement.html#.getUserData">getUserData</a></li><li data-type='method'><a href="module-UserManagement.html#.isDisplayNameAvailable">isDisplayNameAvailable</a></li><li data-type='method'><a href="module-UserManagement.html#.unblockUser">unblockUser</a></li><li data-type='method'><a href="module-UserManagement.html#.updateDisplayName">updateDisplayName</a></li><li data-type='method'><a href="module-UserManagement.html#.uploadPicture">uploadPicture</a></li><li data-type='method'><a href="module-UserManagement.html#.uploadPictureFromS3">uploadPictureFromS3</a></li></ul></li><li><a href="module-UserMemberships.html">UserMemberships</a><ul class='methods'><li data-type='method'><a href="module-UserMemberships.html#.fetchMemberships">fetchMemberships</a></li><li data-type='method'><a href="module-UserMemberships.html#.fetchRechargeTokens">fetchRechargeTokens</a></li></ul></li><li><a href="module-UserNotifications.html">UserNotifications</a><ul class='methods'><li data-type='method'><a href="module-UserNotifications.html#.deleteNotification">deleteNotification</a></li><li data-type='method'><a href="module-UserNotifications.html#.fetchLiveEventPollingState">fetchLiveEventPollingState</a></li><li data-type='method'><a href="module-UserNotifications.html#.fetchNotificationSettings">fetchNotificationSettings</a></li><li data-type='method'><a href="module-UserNotifications.html#.fetchNotifications">fetchNotifications</a></li><li data-type='method'><a href="module-UserNotifications.html#.fetchUnreadCount">fetchUnreadCount</a></li><li data-type='method'><a href="module-UserNotifications.html#.markAllNotificationsAsRead">markAllNotificationsAsRead</a></li><li data-type='method'><a href="module-UserNotifications.html#.markNotificationAsRead">markNotificationAsRead</a></li><li data-type='method'><a href="module-UserNotifications.html#.markNotificationAsUnread">markNotificationAsUnread</a></li><li data-type='method'><a href="module-UserNotifications.html#.pauseLiveEventPolling">pauseLiveEventPolling</a></li><li data-type='method'><a href="module-UserNotifications.html#.restoreNotification">restoreNotification</a></li><li data-type='method'><a href="module-UserNotifications.html#.startLiveEventPolling">startLiveEventPolling</a></li><li data-type='method'><a href="module-UserNotifications.html#.updateNotificationSetting">updateNotificationSetting</a></li></ul></li><li><a href="module-UserProfile.html">UserProfile</a><ul class='methods'><li data-type='method'><a href="module-UserProfile.html#.deleteProfilePicture">deleteProfilePicture</a></li><li data-type='method'><a href="module-UserProfile.html#.otherStats">otherStats</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="ContentOrganization.html">ContentOrganization</a></li><li><a href="Forums.html">Forums</a></li><li><a href="Gamification.html">Gamification</a></li><li><a href="UserManagementSystem.html">UserManagementSystem</a></li></ul><h3><a href="global.html">Global</a></h3>
    
</nav>

<div id="main">
    
    <h1 class="page-title">sanity.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module Sanity-Services
 */
import {
  artistOrInstructorName,
  instructorField,
  chapterField,
  assignmentsField,
  descriptionField,
  resourcesField,
  contentTypeConfig,
  DEFAULT_FIELDS,
  getFieldsForContentType,
  filtersToGroq,
  getUpcomingEventsTypes,
  showsTypes,
  getNewReleasesTypes,
  coachLessonsTypes,
  getFieldsForContentTypeWithFilteredChildren,
  getChildFieldsForContentType,
  SONG_TYPES,
  recentTypes
} from '../contentTypeConfig.js'
import {fetchSimilarItems, recommendations} from './recommendations.js'
import { processMetadata, typeWithSortOrder } from '../contentMetaData.js'

import { globalConfig } from './config.js'

import {
  fetchNextContentDataForParent,
  fetchHandler,
} from './railcontent.js'
import { arrayToStringRepresentation, FilterBuilder } from '../filterBuilder.js'
import { fetchUserPermissions } from './user/permissions.js'
import { getAllCompleted, getAllStarted, getAllStartedOrCompleted } from './contentProgress.js'
import {fetchRecentActivitiesActiveTabs} from "./userActivity.js";

/**
 * Exported functions that are excluded from index generation.
 *
 * @type {string[]}
 */
const excludeFromGeneratedIndex = ['fetchRelatedByLicense']

/**
 * Fetch a song by its document ID from Sanity.
 *
 * @param {string} documentId - The ID of the document to fetch.
 * @returns {Promise&lt;Object|null>} - A promise that resolves to an object containing the song data or null if not found.
 *
 * @example
 * fetchSongById('abc123')
 *   .then(song => console.log(song))
 *   .catch(error => console.error(error));
 */
export async function fetchSongById(documentId) {
  const fields = getFieldsForContentType('song')
  const filterParams = {}
  const query = await buildQuery(
    `_type == "song" &amp;&amp; railcontent_id == ${documentId}`,
    filterParams,
    fields,
    {
      isSingle: true,
    }
  )
  return fetchSanity(query, false)
}

/**
 * fetches from Sanity all content marked for removal next quarter
 *
 * @string brand
 * @number pageNumber
 * @number contentPerPage
 * @returns {Promise&lt;Object|null>}
 */
export async function fetchLeaving(brand, { pageNumber = 1, contentPerPage = 20 } = {}) {
  const today = new Date()
  const isoDateOnly = getDateOnly(today)
  const filterString = `brand == '${brand}' &amp;&amp; quarter_removed > '${isoDateOnly}'`
  const startEndOrder = getQueryFromPage(pageNumber, contentPerPage)
  const sortOrder = {
    sortOrder: 'quarter_removed asc, published_on desc, id desc',
    start: startEndOrder['start'],
    end: startEndOrder['end'],
  }
  const query = await buildQuery(
    filterString,
    { pullFutureContent: false, availableContentStatuses: ['published'] },
    getFieldsForContentType('leaving'),
    sortOrder
  )
  return fetchSanity(query, true)
}

/**
 * fetches from Sanity all content marked for return next quarter
 *
 * @string brand
 * @number pageNumber
 * @number contentPerPage
 * @returns {Promise&lt;Object|null>}
 */
export async function fetchReturning(brand, { pageNumber = 1, contentPerPage = 20 } = {}) {
  const today = new Date()
  const isoDateOnly = getDateOnly(today)
  const filterString = `brand == '${brand}' &amp;&amp; quarter_published >= '${isoDateOnly}'`
  const startEndOrder = getQueryFromPage(pageNumber, contentPerPage)
  const sortOrder = {
    sortOrder: 'quarter_published asc, published_on desc, id desc',
    start: startEndOrder['start'],
    end: startEndOrder['end'],
  }
  const query = await buildQuery(
    filterString,
    { pullFutureContent: true, availableContentStatuses: ['draft'] },
    getFieldsForContentType('returning'),
    sortOrder
  )

  return fetchSanity(query, true)
}

/**
 * fetches from Sanity all songs coming soon (new) next quarter
 *
 * @string brand
 * @number pageNumber
 * @number contentPerPage
 * @returns {Promise&lt;Object|null>}
 */
export async function fetchComingSoon(brand, { pageNumber = 1, contentPerPage = 20 } = {}) {
  const filterString = `brand == '${brand}' &amp;&amp; _type == 'song'`
  const startEndOrder = getQueryFromPage(pageNumber, contentPerPage)
  const sortOrder = {
    sortOrder: 'published_on desc, id desc',
    start: startEndOrder['start'],
    end: startEndOrder['end'],
  }
  const query = await buildQuery(
    filterString,
    { getFutureContentOnly: true },
    getFieldsForContentType(),
    sortOrder
  )
  return fetchSanity(query, true)
}

/**
 *
 * @number page
 * @returns {number[]}
 */
function getQueryFromPage(pageNumber, contentPerPage) {
  const start = contentPerPage * (pageNumber - 1)
  const end = contentPerPage * pageNumber
  let result = []
  result['start'] = start
  result['end'] = end
  return result
}

/**
 * Fetch all artists with lessons available for a specific brand.
 *
 * @param {string} brand - The brand for which to fetch artists.
 * @returns {Promise&lt;Object|null>} - A promise that resolves to an array of artist objects or null if not found.
 *
 * @example
 * fetchArtists('drumeo')
 *   .then(artists => console.log(artists))
 *   .catch(error => console.error(error));
 */
export async function fetchArtists(brand) {
  const filter = await new FilterBuilder(
    `_type == "song" &amp;&amp; brand == "${brand}" &amp;&amp; references(^._id)`,
    { bypassPermissions: true }
  ).buildFilter()
  const query = `
  *[_type == "artist"]{
    name,
    "lessonsCount": count(*[${filter}])
  }[lessonsCount > 0] |order(lower(name)) `
  return fetchSanity(query, true, { processNeedAccess: false })
}

/**
 * Fetch current number of artists for songs within a brand.
 * @param {string} brand - The current brand.
 * @returns {Promise&lt;int|null>} - The fetched count of artists.
 */
export async function fetchSongArtistCount(brand) {
  const filter = await new FilterBuilder(
    `_type == "song" &amp;&amp; brand == "${brand}" &amp;&amp; references(^._id)`,
    { bypassPermissions: true }
  ).buildFilter()
  const query = `
  count(*[_type == "artist"]{
    name,
    "lessonsCount": count(*[${filter}])
  }[lessonsCount > 0])`
  return fetchSanity(query, true, { processNeedAccess: false })
}

export async function fetchPlayAlongsCount(
  brand,
  { searchTerm, includedFields, progressIds, progress }
) {
  const searchFilter = searchTerm
    ? `&amp;&amp; (artist->name match "${searchTerm}*" || instructor[]->name match "${searchTerm}*" || title match "${searchTerm}*" || name match "${searchTerm}*")`
    : ''

  // Construct the included fields filter, replacing 'difficulty' with 'difficulty_string'
  const includedFieldsFilter = includedFields.length > 0 ? filtersToGroq(includedFields) : ''

  // limits the results to supplied progressIds for started &amp; completed filters
  const progressFilter = await getProgressFilter(progress, progressIds)
  const query = `count(*[brand == '${brand}' &amp;&amp; _type == "play-along" ${searchFilter} ${includedFieldsFilter} ${progressFilter} ]) `
  return fetchSanity(query, true, { processNeedAccess: false })
}

/**
 * Fetch related songs for a specific brand and song ID.
 *
 * @param {string} brand - The brand for which to fetch related songs.
 * @param {string} songId - The ID of the song to find related songs for.
 * @returns {Promise&lt;Object|null>} - A promise that resolves to an array of related song objects or null if not found.
 *
 * @example
 * fetchRelatedSongs('drumeo', '12345')
 *   .then(relatedSongs => console.log(relatedSongs))
 *   .catch(error => console.error(error));
 */
export async function fetchRelatedSongs(brand, songId) {
  const now = getSanityDate(new Date())
  const query = `
      *[_type == "song" &amp;&amp; railcontent_id == ${songId}]{
        "entity": array::unique([
            ...(*[_type == "song" &amp;&amp; brand == "${brand}" &amp;&amp; railcontent_id != ${songId} &amp;&amp; references(^.artist->_id)
            &amp;&amp; (status in ['published'] || (status == 'scheduled' &amp;&amp; defined(published_on) &amp;&amp; published_on >= '${now}'))]{
            "type": _type,
            "id": railcontent_id,
            "url": web_url_path,
            "published_on": published_on,
            status,
            "image": thumbnail.asset->url,
            "permission_id": permission[]->railcontent_id,
            "fields": [
              {
                "key": "title",
                "value": title
              },
              {
                "key": "artist",
                "value": artist->name
              },
              {
                "key": "difficulty",
                "value": difficulty
              },
              {
                "key": "length_in_seconds",
                "value": soundslice[0].soundslice_length_in_second
              }
            ],
          }[0...10]),
            ...(*[_type == "song" &amp;&amp; brand == "${brand}" &amp;&amp; railcontent_id != ${songId} &amp;&amp; references(^.genre[]->_id)
            &amp;&amp; (status in ['published'] || (status == 'scheduled' &amp;&amp; defined(published_on) &amp;&amp; published_on >= '${now}'))]{
            "type": _type,
            "id": railcontent_id,
            "url": web_url_path,
            "published_on": published_on,
            "permission_id": permission[]->railcontent_id,
            status,
            "fields": [
              {
                "key": "title",
                "value": title
              },
              {
                "key": "artist",
                "value": artist->name
              },
              {
                "key": "difficulty",
                "value": difficulty
              },
              {
                "key": "length_in_seconds",
                "value": soundslice[0].soundslice_length_in_second
              }
            ],
            "data": [{
              "key": "thumbnail_url",
              "value": thumbnail.asset->url
            }]
          }[0...10])
        ])[0...10]
    }`

  // Fetch the related songs data
  return fetchSanity(query, false)
}

/**
 * Fetch the latest new releases for a specific brand.
 * @param {string} brand - The brand for which to fetch new releases.
 * @returns {Promise&lt;Object|null>} - The fetched new releases data or null if not found.
 */
export async function fetchNewReleases(
  brand,
  { page = 1, limit = 20, sort = '-published_on' } = {}
) {
  const newTypes = getNewReleasesTypes(brand)
  const typesString = arrayToStringRepresentation(newTypes)
  const start = (page - 1) * limit
  const end = start + limit
  const sortOrder = getSortOrder(sort, brand)
  const now = getDateOnly()
  const filter = `_type in ${typesString} &amp;&amp; brand == '${brand}' &amp;&amp; (status == 'published' &amp;&amp; show_in_new_feed == true &amp;&amp; published_on &lt;= '${now}')`
  const fields = `
     "id": railcontent_id,
      title,
      "image": thumbnail.asset->url,
      "thumbnail": thumbnail.asset->url,
      ${artistOrInstructorName()},
      "artists": instructor[]->name,
      difficulty,
      difficulty_string,
      length_in_seconds,
      published_on,
      "type": _type,
      web_url_path,
      "permission_id": permission[]->railcontent_id,
      `
  const query = buildRawQuery(filter, fields, {sortOrder: sortOrder, start, end: end})
  return fetchSanity(query, true)
}

/**
 * Fetch upcoming events for a specific brand.
 *
 * @param {string} brand - The brand for which to fetch upcoming events.
 * @returns {Promise&lt;Object|null>} - A promise that resolves to an array of upcoming event objects or null if not found.
 *
 * @example
 * fetchUpcomingEvents('drumeo', {
 *   page: 2,
 *   limit: 20,
 * })
 *   .then(events => console.log(events))
 *   .catch(error => console.error(error));
 */
export async function fetchUpcomingEvents(brand, { page = 1, limit = 10 } = {}) {
  const now = getSanityDate(new Date())
  const start = (page - 1) * limit
  const end = start + limit
  const fields = `
        "id": railcontent_id,
        title,
        "image": thumbnail.asset->url,
        "thumbnail": thumbnail.asset->url,
        ${artistOrInstructorName()},
        "artists": instructor[]->name,
        difficulty,
        difficulty_string,
        length_in_seconds,
        published_on,
        "type": _type,
        web_url_path,
        "permission_id": permission[]->railcontent_id,
        live_event_start_time,
        live_event_end_time,
         "isLive": live_event_start_time &lt;= '${now}' &amp;&amp; live_event_end_time >= '${now}'`
  const query = buildRawQuery(
    `defined(live_event_start_time) &amp;&amp; (!defined(live_event_end_time) || live_event_end_time >= '${now}' ) &amp;&amp; brand == '${brand}' &amp;&amp; published_on > '${now}' &amp;&amp; status == 'scheduled'`,
    fields,
    {
      sortOrder: 'published_on asc',
      start: start,
      end: end,
    }
  )
  return fetchSanity(query, true)
}

/**
 * Fetch scheduled releases for a specific brand.
 *
 * @param {string} brand - The brand for which to fetch scheduled releasess.
 * @returns {Promise&lt;Object|null>} - A promise that resolves to an array of scheduled release objects or null if not found.
 *
 * @example
 * fetchScheduledReleases('drumeo', {
 *   page: 2,
 *   limit: 20,
 * })
 *   .then(content => console.log(content))
 *   .catch(error => console.error(error));
 */
export async function fetchScheduledReleases(brand, { page = 1, limit = 10 }) {
  const upcomingTypes = getUpcomingEventsTypes(brand)
  const newTypes = getNewReleasesTypes(brand)

  const scheduledTypes = merge(upcomingTypes, newTypes)
  const typesString = arrayJoinWithQuotes(scheduledTypes)
  const now = getSanityDate(new Date())
  const start = (page - 1) * limit
  const end = start + limit
  const query = `*[_type in [${typesString}] &amp;&amp; brand == '${brand}' &amp;&amp; status in ['published','scheduled'] &amp;&amp; (!defined(live_event_end_time) || live_event_end_time &lt; '${now}' ) &amp;&amp; published_on > '${now}']{
      "id": railcontent_id,
      title,
      "image": thumbnail.asset->url,
      "thumbnail": thumbnail.asset->url,
      ${artistOrInstructorName()},
      "artists": instructor[]->name,
      difficulty,
      difficulty_string,
      length_in_seconds,
      published_on,
      "type": _type,
      web_url_path,
      "permission_id": permission[]->railcontent_id,
  } | order(published_on asc)[${start}...${end}]`
  return fetchSanity(query, true)
}

/**
 * Fetch content by a specific Railcontent ID.
 *
 * @param {string} id - The Railcontent ID of the content to fetch.
 * @param {string} contentType - The document type of content to fetch
 * @returns {Promise&lt;Object|null>} - A promise that resolves to the content object or null if not found.
 *
 * @example
 * fetchByRailContentId('abc123')
 *   .then(content => console.log(content))
 *   .catch(error => console.error(error));
 */
export async function fetchByRailContentId(id, contentType) {
  const fields = await getFieldsForContentTypeWithFilteredChildren(contentType)
  const lessonFields = getChildFieldsForContentType(contentType)
  const childrenFilter = await new FilterBuilder(``, { isChildrenFilter: true }).buildFilter()
  const entityFieldsString = ` ${fields}
                                    'child_count': coalesce(count(child[${childrenFilter}]->), 0) ,
                                    "lessons": child[${childrenFilter}]->{${lessonFields}},
                                    'length_in_seconds': coalesce(
      math::sum(
        select(
          child[${childrenFilter}]->length_in_seconds
        )
      ),
      length_in_seconds
    ),`

  const query = buildRawQuery(
    `railcontent_id == ${id} &amp;&amp; _type == '${contentType}'`,
    entityFieldsString,
    {
      isSingle: true,
    }
  )

  return fetchSanity(query, false)
}

/**
 * Fetch content by an array of Railcontent IDs.
 *
 * @param {Array&lt;string>} ids - The array of Railcontent IDs of the content to fetch.
 * @param {string} [contentType] - The content type the IDs to add needed fields to the response.
 * @returns {Promise&lt;Array&lt;Object>|null>} - A promise that resolves to an array of content objects or null if not found.
 *
 * @example
 * fetchByRailContentIds(['abc123', 'def456', 'ghi789'])
 *   .then(contents => console.log(contents))
 *   .catch(error => console.error(error));
 */
export async function fetchByRailContentIds(ids, contentType = undefined, brand = undefined, includePermissionsAndStatusFilter = false) {
  if (!ids?.length) {
    return []
  }
  ids = [...new Set(ids.filter(item => item !== null &amp;&amp; item !== undefined))];
  const idsString = ids.join(',')
  const brandFilter = brand ? ` &amp;&amp; brand == "${brand}"` : ''
  const lessonCountFilter = await new FilterBuilder(`_id in ^.child[]._ref`, {pullFutureContent: true}).buildFilter()
  const fields = await getFieldsForContentTypeWithFilteredChildren(contentType, true)
  const baseFilter = `railcontent_id in [${idsString}]${brandFilter}`
  const finalFilter = includePermissionsAndStatusFilter ? await new FilterBuilder(baseFilter).buildFilter() : baseFilter
  const query = `*[
    ${finalFilter}
  ]{
    ${fields}
    'lesson_count': coalesce(count(*[${lessonCountFilter}]), 0),
    live_event_start_time,
    live_event_end_time,
  }`
  const customPostProcess = (results) => {
    const now = getSanityDate(new Date(), false);
    const liveProcess = (result) => {
      if (result.live_event_start_time &amp;&amp; result.live_event_end_time) {
        result.isLive =
          result.live_event_start_time &lt;= now &amp;&amp;
          result.live_event_end_time >= now;
      } else {
        result.isLive = false;
      }
      return result;
    };
    return results.map(liveProcess);
  }
  const results = await fetchSanity(query, true, { customPostProcess: customPostProcess })

  const sortFuction = function compare(a, b) {
    const indexA = ids.indexOf(a['id'])
    const indexB = ids.indexOf(b['id'])
    if (indexA === indexB) return 0
    if (indexA > indexB) return 1
    return -1
  }

  // Sort results to match the order of the input IDs
  const sortedResults = results?.sort(sortFuction) ?? null

  return sortedResults
}

export async function fetchContentRows(brand, pageName, contentRowSlug)
{
  if (pageName === 'lessons') pageName = 'lesson'
  if (pageName === 'songs') pageName = 'song'
  const rowString = contentRowSlug ? ` &amp;&amp; slug.current == "${contentRowSlug.toLowerCase()}"` : ''
  const lessonCountFilter = await new FilterBuilder(`_id in ^.child[]._ref`, {pullFutureContent: true}).buildFilter()
  const childFilter = await new FilterBuilder('', {isChildrenFilter: true}).buildFilter()
  const query = `*[_type == 'recommended-content-row' &amp;&amp; brand == '${brand}' &amp;&amp; type == '${pageName}'${rowString}]{
    brand,
    name,
    'slug': slug.current,
    'content': content[${childFilter}]->{
        'children': child[${childFilter}]->{ 'id': railcontent_id,
          'type': _type, brand, 'thumbnail': thumbnail.asset->url,
          'children': child[${childFilter}]->{'id': railcontent_id}, },
        ${getFieldsForContentType('tab-data')}
        'lesson_count': coalesce(count(*[${lessonCountFilter}]), 0),
    },
  }`
  return fetchSanity(query, true)
}



/**
 * Fetch all content for a specific brand and type with pagination, search, and grouping options.
 * @param {string} brand - The brand for which to fetch content.
 * @param {string} type - The content type to fetch (e.g., 'song', 'artist').
 * @param {Object} params - Parameters for pagination, filtering, sorting, and grouping.
 * @param {number} [params.page=1] - The page number for pagination.
 * @param {number} [params.limit=10] - The number of items per page.
 * @param {string} [params.searchTerm=""] - The search term to filter content by title or artist.
 * @param {string} [params.sort="-published_on"] - The field to sort the content by.
 * @param {Array&lt;string>} [params.includedFields=[]] - The fields to include in the query.
 * @param {string} [params.groupBy=""] - The field to group the results by (e.g., 'artist', 'genre').
 * @param {Array&lt;string>} [params.progressIds=undefined] - An array of railcontent IDs to filter the results by. Used for filtering by progress.
 * @param {boolean} [params.useDefaultFields=true] - use the default sanity fields for content Type
 * @param {Array&lt;string>} [params.customFields=[]] - An array of sanity fields to include in the request
 * @param {string} [params.progress="all"] - An string representing which progress filter to use ("all", "in progress", "complete", "not started").
 * @returns {Promise&lt;Object|null>} - The fetched content data or null if not found.
 *
 * @example
 * fetchAll('drumeo', 'song', {
 *   page: 2,
 *   limit: 20,
 *   searchTerm: 'jazz',
 *   sort: '-popularity',
 *   includedFields: ['difficulty,Intermediate'],
 *   groupBy: 'artist',
 *   progressIds: [123, 321],
 *   useDefaultFields: false,
 *   customFields: ['is_house_coach', 'slug.current', "'instructors': instructor[]->name"],
 * })
 *   .then(content => console.log(content))
 *   .catch(error => console.error(error));
 */
export async function fetchAll(
  brand,
  type,
  {
    page = 1,
    limit = 10,
    searchTerm = '',
    sort = '-published_on',
    includedFields = [],
    groupBy = '',
    progressIds = undefined,
    useDefaultFields = true,
    customFields = [],
    progress = 'all',
  } = {}
) {
  let config = contentTypeConfig[type] ?? {}
  let additionalFields = config?.fields ?? []
  let isGroupByOneToOne = (groupBy ? config?.relationships?.[groupBy]?.isOneToOne : false) ?? false
  let webUrlPathType = config?.slug ?? type
  const start = (page - 1) * limit
  const end = start + limit
  let bypassStatusAndPublishedValidation =
    type == 'instructor' || groupBy == 'artist' || groupBy == 'genre' || groupBy == 'instructor'
  let bypassPermissions = bypassStatusAndPublishedValidation
  // Construct the type filter
  let typeFilter

  if (type === 'archives') {
    typeFilter = `&amp;&amp; status == "archived"`
    bypassStatusAndPublishedValidation = true
  } else if (type === 'lessons' || type === 'songs') {
    typeFilter = ``
  } else if (type === 'pack') {
    typeFilter = `&amp;&amp; (_type == 'pack' || _type == 'semester-pack')`
  } else {
    typeFilter = type
      ? `&amp;&amp; _type == '${type}'`
      : ''
  }

  // Construct the search filter
  const searchFilter = searchTerm
    ? groupBy !== ''
      ? `&amp;&amp; (^.name match "${searchTerm}*" || title match "${searchTerm}*")`
      : `&amp;&amp; (artist->name match "${searchTerm}*" || instructor[]->name match "${searchTerm}*" || title match "${searchTerm}*" || name match "${searchTerm}*")`
    : ''

  // Construct the included fields filter, replacing 'difficulty' with 'difficulty_string'
  const includedFieldsFilter = includedFields.length > 0 ? filtersToGroq(includedFields) : ''

  // limits the results to supplied progressIds for started &amp; completed filters
  const progressFilter = await getProgressFilter(progress, progressIds)

  // Determine the sort order
  const sortOrder = getSortOrder(sort, brand, groupBy)

  let fields = useDefaultFields
    ? customFields.concat(DEFAULT_FIELDS, additionalFields)
    : customFields
  let fieldsString = fields.join(',')

  let customFilter = ''
  if (type == 'instructor') {
    customFilter = '&amp;&amp; coach_card_image != null'
  }
  // Determine the group by clause
  let query = ''
  let entityFieldsString = ''
  let filter = ''
  if (groupBy !== '' &amp;&amp; isGroupByOneToOne) {
    const webUrlPath = 'artists'
    const lessonsFilter = `_type == '${type}' &amp;&amp; brand == '${brand}' &amp;&amp; ^._id == ${groupBy}._ref ${searchFilter} ${includedFieldsFilter} ${progressFilter} ${customFilter}`
    const lessonsFilterWithRestrictions = await new FilterBuilder(lessonsFilter).buildFilter()
    entityFieldsString = `
                'id': railcontent_id,
                'type': _type,
                name,
                'head_shot_picture_url': thumbnail_url.asset->url,
                'web_url_path': '/${brand}/${webUrlPath}/'+name+'?included_fieds[]=type,${type}',
                'all_lessons_count': count(*[${lessonsFilterWithRestrictions}]._id),
                'lessons': *[${lessonsFilterWithRestrictions}]{
                    ${fieldsString},
                    ${groupBy}
                }[0...20]
        `
    filter = `_type == '${groupBy}' &amp;&amp; count(*[${lessonsFilterWithRestrictions}]._id) > 0`
  } else if (groupBy !== '') {
    const childrenFilter = await new FilterBuilder(``, { isChildrenFilter: true }).buildFilter()

    const webUrlPath = groupBy == 'genre' ? '/genres' : ''
    const lessonsFilter = `brand == '${brand}' &amp;&amp; ^._id in ${groupBy}[]._ref ${typeFilter} ${searchFilter} ${includedFieldsFilter} ${progressFilter} ${customFilter}`
    const lessonsFilterWithRestrictions = await new FilterBuilder(lessonsFilter).buildFilter()

    entityFieldsString = `
                'id': railcontent_id,
                'type': _type,
                name,
                'head_shot_picture_url': thumbnail_url.asset->url,
                'web_url_path': select(defined(web_url_path)=> web_url_path +'?included_fieds[]=type,${type}',!defined(web_url_path)=> '/${brand}${webUrlPath}/'+name+'/${webUrlPathType}'),
                'all_lessons_count': count(*[${lessonsFilterWithRestrictions}]._id),
                'lessons': *[${lessonsFilterWithRestrictions}]{
                    ${fieldsString},
                     'lesson_count': coalesce(count(child[${childrenFilter}]->), 0) ,
                    ${groupBy}
                }[0...20]`
    filter = `_type == '${groupBy}' &amp;&amp; count(*[${lessonsFilterWithRestrictions}]._id) > 0`
  } else {
    filter = `brand == "${brand}" ${typeFilter} ${searchFilter} ${includedFieldsFilter} ${progressFilter} ${customFilter}`
    const childrenFilter = await new FilterBuilder(``, { isChildrenFilter: true }).buildFilter()
    entityFieldsString = ` ${fieldsString},
                                    'lesson_count': coalesce(count(child[${childrenFilter}]->), 0) ,
                                    'length_in_seconds': coalesce(
      math::sum(
        select(
          child[${childrenFilter}]->length_in_seconds
        )
      ),
      length_in_seconds
    ),`
  }

  const filterWithRestrictions = await new FilterBuilder(filter, {
    bypassStatuses: bypassStatusAndPublishedValidation,
    bypassPermissions: bypassPermissions,
    bypassPublishedDateRestriction: bypassStatusAndPublishedValidation,
  }).buildFilter()
  query = buildEntityAndTotalQuery(filterWithRestrictions, entityFieldsString, {
    sortOrder: sortOrder,
    start: start,
    end: end,
  })

  return fetchSanity(query, true)
}

async function getProgressFilter(progress, progressIds) {
  switch (progress) {
    case 'all':
      return progressIds !== undefined ? `&amp;&amp; railcontent_id in [${progressIds.join(',')}]` : ''
    case 'in progress': {
      const ids = await getAllStarted()
      return `&amp;&amp; railcontent_id in [${ids.join(',')}]`
    }
    case 'completed': {
      const ids = await getAllCompleted()
      return `&amp;&amp; railcontent_id in [${ids.join(',')}]`
    }
    case 'not started': {
      const ids = await getAllStartedOrCompleted()
      return `&amp;&amp; !(railcontent_id in [${ids.join(',')}])`
    }
    case 'recent': {
      const ids = progressIds !== undefined ? progressIds : await getAllStartedOrCompleted()
      return `&amp;&amp; (railcontent_id in [${ids.join(',')}])`
    }
    case 'incomplete': {
      const ids = progressIds !== undefined ? progressIds :await getAllStarted()
      return `&amp;&amp; railcontent_id in [${ids.join(',')}]`
    }
    default:
      throw new Error(`'${progress}' progress option not implemented`)
  }
}

export function getSortOrder(sort = '-published_on', brand, groupBy) {
  // Determine the sort order
  let sortOrder = ''
  let isDesc = sort.startsWith('-')
  sort = isDesc ? sort.substring(1) : sort
  switch (sort) {
    case 'slug':
      sortOrder = groupBy ? 'name' : '!defined(title), lower(title)'
      break
    case 'name':
      sortOrder = sort
      break
    case 'popularity':
      if (groupBy == 'artist' || groupBy == 'genre') {
        sortOrder = isDesc ? `coalesce(popularity.${brand}, -1)` : 'popularity'
      } else {
        sortOrder = isDesc ? 'coalesce(popularity, -1)' : 'popularity'
      }
      break
    case 'recommended':
      sortOrder = 'published_on'
      isDesc = true
      break
    case 'published_on':
    default:
      sortOrder = 'published_on'
      break
  }
  sortOrder += isDesc ? ' desc' : ' asc'
  return sortOrder
}

/**
 * Fetches all available filter options based on brand, filters, and various optional criteria.
 *
 * This function constructs a query to retrieve the total number of results and filter options such as difficulty, instrument type, and genre.
 * The filter options are dynamically generated based on the provided filters, style, artist, and content type.
 * If a coachId is provided, the content type must be 'coach-lessons'.
 *
 * @param {string} brand - Brand to filter.
 * @param {string[]} filters - Key-value pairs to filter the query.
 * @param {string} [style] - Optional style/genre filter.
 * @param {string} [artist] - Optional artist name filter.
 * @param {string} contentType - Content type (e.g., 'song', 'lesson').
 * @param {string} [term] - Optional search term for title, album, artist, or genre.
 * @param {Array&lt;string>} [progressIds] - Optional array of progress IDs to filter by.
 * @param {string} [coachId] - Optional coach ID (only valid if contentType is 'coach-lessons').
 * @param {boolean} [includeTabs=false] - Whether to include tabs in the returned metadata.
 * @returns {Promise&lt;Object>} - The filter options and metadata.
 * @throws {Error} If coachId is provided but contentType isn't 'coach-lessons'.
 *
 * @example
 * // Fetch filter options for 'song' content type:
 * fetchAllFilterOptions('myBrand', [], 'Rock', 'John Doe', 'song', 'Love')
 *   .then(options => console.log(options))
 *   .catch(error => console.error(error));
 *
 * @example
 * // Fetch filter options for a coach's lessons with coachId:
 * fetchAllFilterOptions('myBrand', [], 'Rock', 'John Doe', 'coach-lessons', 'Love', undefined, '123')
 *   .then(options => console.log(options))
 *   .catch(error => console.error(error));
 */
export async function fetchAllFilterOptions(
  brand,
  filters = [],
  style,
  artist,
  contentType,
  term,
  progressIds,
  coachId,
  includeTabs = false
) {
  if (contentType == 'lessons' || contentType == 'songs') {
    const metaData = processMetadata(brand, contentType, true)
    return {
      meta: metaData,
    }
  }

  if (coachId &amp;&amp; contentType !== 'coach-lessons') {
    throw new Error(
      `Invalid contentType: '${contentType}' for coachId. It must be 'coach-lessons'.`
    )
  }

  const includedFieldsFilter = filters?.length ? filtersToGroq(filters) : undefined
  const progressFilter = progressIds ? `&amp;&amp; railcontent_id in [${progressIds.join(',')}]` : ''
  const isAdmin = (await fetchUserPermissions()).isAdmin

  const constructCommonFilter = (excludeFilter) => {
    const filterWithoutOption = excludeFilter
      ? filtersToGroq(filters, excludeFilter)
      : includedFieldsFilter
    const statusFilter = ' &amp;&amp; status == "published"'
    const includeStatusFilter = !isAdmin &amp;&amp; !['instructor', 'artist', 'genre'].includes(contentType)

    return coachId
      ? `brand == '${brand}' &amp;&amp; status == "published" &amp;&amp; references(*[_type=='instructor' &amp;&amp; railcontent_id == ${coachId}]._id) ${filterWithoutOption || ''} ${term ? ` &amp;&amp; (title match "${term}" || album match "${term}" || artist->name match "${term}" || genre[]->name match "${term}")` : ''}`
      : `_type == '${contentType}' &amp;&amp; brand == "${brand}"${includeStatusFilter ? statusFilter : ''}${style &amp;&amp; excludeFilter !== 'style' ? ` &amp;&amp; '${style}' in genre[]->name` : ''}${artist &amp;&amp; excludeFilter !== 'artist' ? ` &amp;&amp; artist->name == '${artist}'` : ''} ${progressFilter} ${filterWithoutOption || ''} ${term ? ` &amp;&amp; (title match "${term}" || album match "${term}" || artist->name match "${term}" || genre[]->name match "${term}")` : ''}`
  }

  const metaData = processMetadata(brand, contentType, true)
  const allowableFilters = metaData?.allowableFilters || []
  const tabs = metaData?.tabs || []
  const catalogName = metaData?.shortname || metaData?.name

  const dynamicFilterOptions = allowableFilters
    .map((filter) => getFilterOptions(filter, constructCommonFilter(filter), contentType, brand))
    .join(' ')

  const query = `
      {
        "meta": {
          "totalResults": count(*[${constructCommonFilter()}
            ${term ? ` &amp;&amp; (title match "${term}" || album match "${term}" || artist->name match "${term}" || genre[]->name match "${term}")` : ''}]),
          "filterOptions": {
            ${dynamicFilterOptions}
          }
      }
    }`

  const results = await fetchSanity(query, true, { processNeedAccess: false })

  return includeTabs ? { ...results, tabs, catalogName } : results
}

/**
 * Fetch the Foundations 2019.
 * @param {string} slug - The slug of the method.
 * @returns {Promise&lt;Object|null>} - The fetched foundation data or null if not found.
 */
export async function fetchFoundation(slug) {
  const filterParams = {}
  const query = await buildQuery(
    `_type == 'foundation' &amp;&amp; slug.current == "${slug}"`,
    filterParams,
    getFieldsForContentType('foundation'),
    {
      sortOrder: 'published_on asc',
      isSingle: true,
    }
  )
  return fetchSanity(query, false)
}

/**
 * Fetch the Method (learning-paths) for a specific brand.
 * @param {string} brand - The brand for which to fetch methods.
 * @param {string} slug - The slug of the method.
 * @returns {Promise&lt;Object|null>} - The fetched methods data or null if not found.
 */
export async function fetchMethod(brand, slug) {
  const childrenFilter = await new FilterBuilder(``, { isChildrenFilter: true }).buildFilter()

  const query = `*[_type == 'learning-path' &amp;&amp; brand == "${brand}" &amp;&amp; slug.current == "${slug}"] {
    "description": ${descriptionField},
    "instructors":instructor[]->name,
    published_on,
    "id": railcontent_id,
    railcontent_id,
    "slug": slug.current,
    status,
    title,
    video,
    length_in_seconds,
    parent_content_data,
    "breadcrumbs_data": parent_content_data[] {
        "id": id,
        "title": *[railcontent_id == ^.id][0].title,
        "url": *[railcontent_id == ^.id][0].web_url_path
    } | order(length(url)),
    "type": _type,
    "permission_id": permission[]->railcontent_id,
    "levels": child[${childrenFilter}]->
      {
        "id": railcontent_id,
        published_on,
        child_count,
        difficulty,
        difficulty_string,
        "thumbnail": thumbnail.asset->url,
        "instructor": instructor[]->{name},
        title,
        "type": _type,
        "description": ${descriptionField},
        "url": web_url_path,
        web_url_path,
        xp,
        total_xp
      }
  } | order(published_on asc)`
  return fetchSanity(query, false)
}

/**
 * Fetch the child courses for a specific method by Railcontent ID.
 * @param {string} railcontentId - The Railcontent ID of the current lesson.
 * @returns {Promise&lt;Object|null>} - The fetched next lesson data or null if not found.
 */
export async function fetchMethodChildren(railcontentId) {
  const childrenFilter = await new FilterBuilder(``, { isChildrenFilter: true }).buildFilter()

  const query = `*[railcontent_id == ${railcontentId}]{
    "child_count":coalesce(count(child[${childrenFilter}]->), 0),
    "id": railcontent_id,
    "description": ${descriptionField},
    "thumbnail": thumbnail.asset->url,
    title,
    xp,
    total_xp,
    parent_content_data,
     "resources": ${resourcesField},
    "breadcrumbs_data": parent_content_data[] {
        "id": id,
        "title": *[railcontent_id == ^.id][0].title,
        "url": *[railcontent_id == ^.id][0].web_url_path
    } | order(length(url)),
    'children': child[(${childrenFilter})]->{
        ${getFieldsForContentType('method')}
    },
  }[0..1]`
  return fetchSanity(query, true)
}

/**
 * Fetch the next lesson for a specific method by Railcontent ID.
 * @param {string} railcontentId - The Railcontent ID of the current lesson.
 * @param {string} methodId - The RailcontentID of the method
 * @returns {Promise&lt;Object|null>} - object with `nextLesson` and `previousLesson` attributes
 * @example
 * fetchMethodPreviousNextLesson(241284, 241247)
 *  .then(data => { console.log('nextLesson', data.nextLesson); console.log('prevlesson', data.prevLesson);})
 *  .catch(error => console.error(error));
 */
export async function fetchMethodPreviousNextLesson(railcontentId, methodId) {
  const sortedChildren = await fetchMethodChildrenIds(methodId)
  const index = sortedChildren.indexOf(Number(railcontentId))
  let nextId = sortedChildren[index + 1]
  let previousId = sortedChildren[index - 1]
  let ids = []
  if (nextId) ids.push(nextId)
  if (previousId) ids.push(previousId)
  let nextPrev = await fetchByRailContentIds(ids)
  const nextLesson = nextPrev.find((elem) => {
    return elem['id'] === nextId
  })
  const prevLesson = nextPrev.find((elem) => {
    return elem['id'] === previousId
  })
  return { nextLesson, prevLesson }
}

/**
 * Fetch all children of a specific method by Railcontent ID.
 * @param {string} railcontentId - The Railcontent ID of the method.
 * @returns {Promise&lt;Array&lt;Object>|null>} - The fetched children data or null if not found.
 */
export async function fetchMethodChildrenIds(railcontentId) {
  const childrenFilter = await new FilterBuilder(``, { isChildrenFilter: true }).buildFilter()

  const query = `*[ railcontent_id == ${railcontentId}]{
    'children': child[${childrenFilter}]-> {
        'id': railcontent_id,
        'type' : _type,
            'children': child[${childrenFilter}]-> {
                'id': railcontent_id,
                'type' : _type,
                    'children': child[${childrenFilter}]-> {
                        'id': railcontent_id,
                        'type' : _type,
            }
        }
    }
}`
  let allChildren = await fetchSanity(query, false)
  return getChildrenToDepth(allChildren, 4)
}

function getChildrenToDepth(parent, depth = 1) {
  let allChildrenIds = []
  if (parent &amp;&amp; parent['children'] &amp;&amp; depth > 0) {
    parent['children'].forEach((child) => {
      if (!child['children']) {
        allChildrenIds.push(child['id'])
      }
      allChildrenIds = allChildrenIds.concat(getChildrenToDepth(child, depth - 1))
    })
  }
  return allChildrenIds
}

/**
 * Fetch the next and previous lessons for a specific lesson by Railcontent ID.
 * @param {string} railcontentId - The Railcontent ID of the current lesson.
 * @returns {Promise&lt;Object|null>} - The fetched next and previous lesson data or null if found.
 */
export async function fetchNextPreviousLesson(railcontentId) {
  const document = await fetchLessonContent(railcontentId)
  if (document.parent_content_data &amp;&amp; document.parent_content_data.length > 0) {
    const lastElement = document.parent_content_data[document.parent_content_data.length - 1]
    const results = await fetchMethodPreviousNextLesson(railcontentId, lastElement.id)
    return results
  }
  const processedData = processMetadata(document.brand, document.type, true)
  let sortBy = processedData?.sortBy ?? 'published_on'
  const isDesc = sortBy.startsWith('-')
  sortBy = isDesc ? sortBy.substring(1) : sortBy
  let sortValue = document[sortBy]
  if (sortValue == null) {
    sortBy = 'railcontent_id'
    sortValue = document['railcontent_id']
  }
  const isNumeric = !isNaN(sortValue)
  let prevComparison = isNumeric ? `${sortBy} &lt;= ${sortValue}` : `${sortBy} &lt;= "${sortValue}"`
  let nextComparison = isNumeric ? `${sortBy} >= ${sortValue}` : `${sortBy} >= "${sortValue}"`
  const fields = getFieldsForContentType(document.type)
  const query = `{
      "prevLesson": *[brand == "${document.brand}" &amp;&amp; status == "${document.status}" &amp;&amp; _type == "${document.type}" &amp;&amp; ${prevComparison} &amp;&amp; railcontent_id != ${railcontentId}] | order(${sortBy} desc){${fields}}[0...1][0],
      "nextLesson": *[brand == "${document.brand}" &amp;&amp; status == "${document.status}" &amp;&amp; _type == "${document.type}" &amp;&amp; ${nextComparison} &amp;&amp; railcontent_id != ${railcontentId}] | order(${sortBy} asc){${fields}}[0...1][0]
    }`

  return await fetchSanity(query, true)
}

/**
 * Fetch the next piece of content under a parent by Railcontent ID
 * @param {int} railcontentId - The Railcontent ID of the parent content
 * @returns {Promise&lt;{next: (Object|null)}|null>} - object with 'next' attribute
 * @example
 * jumpToContinueContent(296693)
 *  then.(data => { console.log('next', data.next);})
 *  .catch(error => console.error(error));
 */
export async function jumpToContinueContent(railcontentId) {
  const nextContent = await fetchNextContentDataForParent(railcontentId)
  if (!nextContent || !nextContent.id) {
    return null
  }
  let next = await fetchByRailContentId(nextContent.id, nextContent.type)
  return { next }
}

/**
 * Fetch the page data for a specific lesson by Railcontent ID.
 * @param {string} railContentId - The Railcontent ID of the current lesson.
 * @parent {boolean} addParent - Whether to include parent content data in the response.
 * @returns {Promise&lt;Object|null>} - The fetched page data or null if found.
 *
 * @example
 * fetchLessonContent('lesson123')
 *   .then(data => console.log(data))
 *   .catch(error => console.error(error));
 */
export async function fetchLessonContent(railContentId, { addParent = false } = {}) {
  const filterParams = { isSingle: true, pullFutureContent: true }

  const parentQuery = addParent
    ? `"parent_content_data": *[railcontent_id in [...(^.parent_content_data[].id)]]{
      "id": railcontent_id,
      title,
      slug,
      "type": _type,
      "logo" : logo_image_url.asset->url,
      "dark_mode_logo": dark_mode_logo_url.asset->url,
      "light_mode_logo": light_mode_logo_url.asset->url,
      "badge": *[references(^._id) &amp;&amp; _type == 'content-award'][0].badge.asset->url,
    },`
    : ''

  const fields = `${getFieldsForContentType()}
    "resources": ${resourcesField},
    soundslice,
    instrumentless,
    soundslice_slug,
    "description": ${descriptionField},
    "chapters": ${chapterField},
    "instructors":instructor[]->name,
    "instructor": ${instructorField},
    ${assignmentsField}
    video,
    length_in_seconds,
    mp3_no_drums_no_click_url,
    mp3_no_drums_yes_click_url,
    mp3_yes_drums_no_click_url,
    mp3_yes_drums_yes_click_url,
    "permission_id": permission[]->railcontent_id,
    ${parentQuery}
    ...select(
      defined(live_event_start_time) => {
        "live_event_start_time": live_event_start_time,
        "live_event_end_time": live_event_end_time,
        "live_event_youtube_id": live_event_youtube_id,
        "videoId": coalesce(live_event_youtube_id, video.external_id),
        "live_event_is_global": live_global_event == true
      }
    )
  `

  const query = await buildQuery(`railcontent_id == ${railContentId}`, filterParams, fields, {
    isSingle: true,
  })
  const chapterProcess = (result) => {
    const now = getSanityDate(new Date(), false)
    if (result.live_event_start_time &amp;&amp; result.live_event_end_time) {
      result.isLive = result.live_event_start_time &lt;= now &amp;&amp; result.live_event_end_time >= now
    }
    const chapters = result.chapters ?? []
    if (chapters.length === 0) return result
    result.chapters = chapters.map((chapter, index) => ({
      ...chapter,
      chapter_thumbnail_url: `https://musora-web-platform.s3.amazonaws.com/chapters/${result.brand}/Chapter${index + 1}.jpg`,
    }))
    return result
  }

  return fetchSanity(query, false, { customPostProcess: chapterProcess })
}

/**
 * Returns a list of recommended content based on the provided railContentId.
 * If no recommendations found in recsys, falls back to fetching related lessons.
 *
 * @param railContentId
 * @param brand
 * @param count
 * @returns {Promise&lt;Array&lt;Object>>}
 */
export async function fetchRelatedRecommendedContent(railContentId, brand, count = 10) {
  const recommendedItems = await fetchSimilarItems(railContentId, brand, count)
  if (recommendedItems &amp;&amp; recommendedItems.length > 0) {
    return fetchByRailContentIds(recommendedItems, 'tab-data', brand, true)
  }

  return await fetchRelatedLessons(railContentId, brand).then((result) =>
    result.related_lessons?.splice(0, count)
  )
}

/**
 * Get song type (transcriptions, jam packs, play alongs, tutorial children) content documents that share content information with the provided railcontent document.
 * These are linked through content that shares a license with the provided railcontent document
 *
 * @param railcontentId
 * @param brand
 * @param count
 * @returns {Promise&lt;Array&lt;Object>>}
 */
export async function fetchOtherSongVersions(railcontentId, brand, count = 3) {
  return fetchRelatedByLicense(railcontentId, brand, true, count)
}

/**
 * Get non-song content documents that share content information with the provided railcontent document.
 * These are linked through content that shares a license with the provided railcontent document
 *
 * @param {integer} railcontentId
 * @param {string} brand
 * @param {integer:3} count
 * @returns {Promise&lt;Array&lt;Object>>}
 */
export async function fetchLessonsFeaturingThisContent(railcontentId, brand, count = 3) {
  return fetchRelatedByLicense(railcontentId, brand, false, count)
}

/**
 * Get content documents that share license information with the provided railcontent id
 *
 * @param {integer} railcontentId
 * @param {string} brand
 * @param {boolean} onlyUseSongTypes - if true, only return the song type documents. If false, return everything except those
 * @param {integer:3} count
 * @returns {Promise&lt;Array&lt;Object>>}
 */
async function fetchRelatedByLicense(railcontentId, brand, onlyUseSongTypes, count) {
  const typeCheck = `@->_type in [${arrayJoinWithQuotes(SONG_TYPES)}]`
  let typeCheckString = `@->brand == '${brand}' &amp;&amp; `
  typeCheckString += onlyUseSongTypes ? `${typeCheck}` : `!(${typeCheck})`
  const contentFromLicenseFilter = `_type == 'license' &amp;&amp; references(^._id)].content[${typeCheckString} &amp;&amp; @->railcontent_id != ${railcontentId}`
  let filterSongTypesWithSameLicense = await new FilterBuilder(contentFromLicenseFilter, {
    isChildrenFilter: true,
  }).buildFilter()
  let queryFields = getFieldsForContentType()
  const baseParentQuery = `railcontent_id == ${railcontentId}`
  let parentQuery = await new FilterBuilder(baseParentQuery).buildFilter()

  // queryFields = 'railcontent_id, title'
  // parentQuery = baseParentQuery
  // filterSongTypesWithSameLicense = contentFromLicenseFilter
  const query = `*[${parentQuery}]{
   _type, railcontent_id,
      "related_by_license" :
          *[${filterSongTypesWithSameLicense}]->{${queryFields}}|order(published_on desc, title asc)[0...${count}],
      }[0...1]`
  const results = await fetchSanity(query, false)
  return results ? results['related_by_license'] ?? [] : []
}

/**
 * Fetch sibling lessons to a specific lesson
 * @param {string} railContentId - The RailContent ID of the current lesson.
 * @param {string} brand - The current brand.
 * @returns {Promise&lt;Array&lt;Object>|null>} - The fetched related lessons data or null if not found.
 */
export async function fetchSiblingContent(railContentId, brand= null)
{
  const filterGetParent = await new FilterBuilder(`references(^._id) &amp;&amp; _type == ^.parent_type`, {
    pullFutureContent: true
  }).buildFilter()
  const filterForParentList = await new FilterBuilder(`references(^._id) &amp;&amp; _type == ^.parent_type`, {
    pullFutureContent: true,
    isParentFilter: true,
  }).buildFilter()

  const childrenFilter = await new FilterBuilder(``, { isChildrenFilter: true }).buildFilter()

  const brandString = brand ? ` &amp;&amp; brand == "${brand}"` : ''
  const queryFields = `_id, "id":railcontent_id, published_on, "instructor": instructor[0]->name, title, "thumbnail":thumbnail.asset->url, length_in_seconds, status, "type": _type, difficulty, difficulty_string, artist->, "permission_id": permission[]->railcontent_id, "genre": genre[]->name, "parent_id": parent_content_data[0].id`

  const query = `*[railcontent_id == ${railContentId}${brandString}]{
   _type, parent_type, 'parent_id': parent_content_data[0].id, railcontent_id,
   'for-calculations': *[${filterGetParent}][0]{
    'siblings-list': child[]->railcontent_id,
    'parents-list': *[${filterForParentList}][0].child[]->railcontent_id
    },
    "related_lessons" : *[${filterGetParent}][0].child[${childrenFilter}]->{${queryFields}}
  }`

  let result = await fetchSanity(query, false)

  //there's no way in sanity to retrieve the index of an array, so we must calculate after fetch
  if (result['for-calculations'] &amp;&amp; result['for-calculations']['parents-list']) {
    const calc = result['for-calculations']
    const parentCount = calc['parents-list'].length
    const currentParentIndex = calc['parents-list'].indexOf(result['parent_id']) + 1
    const siblingCount = calc['siblings-list'].length
    const currentSiblingIndex = calc['siblings-list'].indexOf(result['railcontent_id']) + 1

    delete result['for-calculations']
    result = { ...result, parentCount, currentParentIndex, siblingCount, currentSiblingIndex }
    return result
  } else {
    delete result['for-calculations']
    return result
  }
}

/**
 * Fetch lessons related to a specific lesson by RailContent ID and type.
 * @param {string} railContentId - The RailContent ID of the current lesson.
 * @returns {Promise&lt;Array&lt;Object>|null>} - The fetched related lessons data or null if not found.
 */
export async function fetchRelatedLessons(railContentId)
{
  const defaultFilterFields = `_type==^._type &amp;&amp; brand == ^.brand &amp;&amp; railcontent_id != ${railContentId}`

  const filterSameArtist = await new FilterBuilder(
    `${defaultFilterFields} &amp;&amp; references(^.artist->_id)`
  ).buildFilter()
  const filterSameGenre = await new FilterBuilder(
    `${defaultFilterFields} &amp;&amp; references(^.genre[]->_id)`
  ).buildFilter()

  const queryFields = `_id, "id":railcontent_id, published_on, "instructor": instructor[0]->name, title, "thumbnail":thumbnail.asset->url, length_in_seconds, status, "type": _type, difficulty, difficulty_string, railcontent_id, artist->,"permission_id": permission[]->railcontent_id,_type, "genre": genre[]->name`

  const query = `*[railcontent_id == ${railContentId} &amp;&amp; (!defined(permission) || references(*[_type=='permission']._id))]{
   _type, parent_type, railcontent_id,
    "related_lessons" : array::unique([
      ...(*[${filterSameArtist}]{${queryFields}}|order(published_on desc, title asc)[0...10]),
      ...(*[${filterSameGenre}]{${queryFields}}|order(published_on desc, title asc)[0...10]),
      ])[0...10]}`

  return await fetchSanity(query, false)
}

/**
 * Fetch all packs.
 * @param {string} brand - The brand for which to fetch packs.
 * @param {string} [searchTerm=""] - The search term to filter packs.
 * @param {string} [sort="-published_on"] - The field to sort the packs by.
 * @param {number} [params.page=1] - The page number for pagination.
 * @param {number} [params.limit=10] - The number of items per page.
 * @returns {Promise&lt;Array&lt;Object>|null>} - The fetched pack content data or null if not found.
 */
export async function fetchAllPacks(
  brand,
  sort = '-published_on',
  searchTerm = '',
  page = 1,
  limit = 10
) {
  const sortOrder = getSortOrder(sort, brand)
  const filter = `(_type == 'pack' || _type == 'semester-pack') &amp;&amp; brand == '${brand}' &amp;&amp; title match "${searchTerm}*"`
  const filterParams = {}
  const fields = getFieldsForContentType('pack')
  const start = (page - 1) * limit
  const end = start + limit

  const query = await buildQuery(filter, filterParams, getFieldsForContentType('pack'), {
    logo_image_url: 'logo_image_url.asset->url',
    sortOrder: sortOrder,
    start,
    end,
  })
  return fetchSanity(query, true)
}

/**
 * Fetch all content for a specific pack by Railcontent ID.
 * @param {string} railcontentId - The Railcontent ID of the pack.
 * @returns {Promise&lt;Array&lt;Object>|null>} - The fetched pack content data or null if not found.
 */
export async function fetchPackAll(railcontentId, type = 'pack') {
  return fetchByRailContentId(railcontentId, type)
}

export async function fetchLiveEvent(brand, forcedContentId = null) {
  const LIVE_EXTRA_MINUTES = 30
  //calendarIDs taken from addevent.php
  // TODO import instructor calendars to Sanity
  let defaultCalendarID = ''
  switch (brand) {
    case 'drumeo':
      defaultCalendarID = 'GP142387'
      break
    case 'pianote':
      defaultCalendarID = 'be142408'
      break
    case 'guitareo':
      defaultCalendarID = 'IJ142407'
      break
    case 'singeo':
      defaultCalendarID = 'bk354284'
      break
    default:
      break
  }
  let startDateTemp = new Date()
  let endDateTemp = new Date()

  startDateTemp = new Date(
    startDateTemp.setMinutes(startDateTemp.getMinutes() + LIVE_EXTRA_MINUTES)
  )
  endDateTemp = new Date(endDateTemp.setMinutes(endDateTemp.getMinutes() - LIVE_EXTRA_MINUTES))

  // See LiveStreamEventService.getCurrentOrNextLiveEvent for some nice complicated logic which I don't think is actually importart
  // this has some +- on times
  // But this query just finds the first scheduled event (sorted by start_time) that ends after now()
  const query =
    forcedContentId !== null
      ? `*[railcontent_id == ${forcedContentId} ]{
      'slug': slug.current,
      'id': railcontent_id,
      live_event_start_time,
      live_event_end_time,
      live_event_youtube_id,
      railcontent_id,
      published_on,
      'event_coach_url' : instructor[0]->web_url_path,
      'event_coach_calendar_id': coalesce(calendar_id, '${defaultCalendarID}'),
      title,
      "thumbnail": thumbnail.asset->url,
      ${artistOrInstructorName()},
      difficulty_string,
      "instructors": ${instructorField},
      'videoId': coalesce(live_event_youtube_id, video.external_id),
    } | order(live_event_start_time)[0...1]`
      : `*[status == 'scheduled' &amp;&amp; brand == '${brand}' &amp;&amp; defined(live_event_start_time) &amp;&amp; live_event_start_time &lt;= '${getSanityDate(startDateTemp, false)}' &amp;&amp; live_event_end_time >= '${getSanityDate(endDateTemp, false)}']{
      'slug': slug.current,
      'id': railcontent_id,
      live_event_start_time,
      live_event_end_time,
      live_event_youtube_id,
      railcontent_id,
      published_on,
      'event_coach_url' : instructor[0]->web_url_path,
      'event_coach_calendar_id': coalesce(calendar_id, '${defaultCalendarID}'),
      title,
      "thumbnail": thumbnail.asset->url,
      ${artistOrInstructorName()},
      difficulty_string,
      "instructors": instructor[]->{
            name,
            web_url_path,
          },
      'videoId': coalesce(live_event_youtube_id, video.external_id),
    } | order(live_event_start_time)[0...1]`

  return await fetchSanity(query, false, { processNeedAccess: false })
}

/**
 * Fetch the data needed for the Pack Overview screen.
 * @param {number} id - The Railcontent ID of the pack
 * @returns {Promise&lt;Object|null>} - The pack information and lessons or null if not found.
 *
 * @example
 * fetchPackData(404048)
 *   .then(pack => console.log(pack))
 *   .catch(error => console.error(error));
 */
export async function fetchPackData(id) {
  const builder = await new FilterBuilder(`railcontent_id == ${id}`).buildFilter()
  const query = `*[${builder}]{
    ${await getFieldsForContentTypeWithFilteredChildren('pack')}
  } [0...1]`
  return fetchSanity(query, false)
}

/**
 * Fetch the data needed for the coach screen.
 * @param {string} brand - The brand for which to fetch coach lessons
 * @param {string} id - The Railcontent ID of the coach
 * @returns {Promise&lt;Object|null>} - The lessons for the instructor or null if not found.
 * @param {Object} params - Parameters for pagination, filtering and sorting.
 * @param {string} [params.sortOrder="-published_on"] - The field to sort the lessons by.
 * @param {string} [params.searchTerm=""] - The search term to filter content by title.
 * @param {number} [params.page=1] - The page number for pagination.
 * @param {number} [params.limit=10] - The number of items per page.
 * @param {Array&lt;string>} [params.includedFields=[]] - Additional filters to apply to the query in the format of a key,value array. eg. ['difficulty,Intermediate', 'genre,rock'].
 *
 * @example
 * fetchCoachLessons('coach123')
 *   .then(lessons => console.log(lessons))
 *   .catch(error => console.error(error));
 */
export async function fetchCoachLessons(
  brand,
  id,
  { sortOrder = '-published_on', searchTerm = '', page = 1, limit = 20, includedFields = [] } = {}
) {
  const fieldsString = getFieldsForContentType()
  const start = (page - 1) * limit
  const end = start + limit
  const searchFilter = searchTerm ? `&amp;&amp; title match "${searchTerm}*"` : ''
  const includedFieldsFilter = includedFields.length > 0 ? filtersToGroq(includedFields) : ''
  const filter = `brand == '${brand}' ${searchFilter} ${includedFieldsFilter} &amp;&amp; references(*[_type=='instructor' &amp;&amp; railcontent_id == ${id}]._id)`
  const filterWithRestrictions = await new FilterBuilder(filter).buildFilter()

  sortOrder = getSortOrder(sortOrder, brand)
  const query = buildEntityAndTotalQuery(filterWithRestrictions, fieldsString, {
    sortOrder: sortOrder,
    start: start,
    end: end,
  })
  return fetchSanity(query, true)
}

/**
 * Fetch the data needed for the Course Overview screen.
 * @param {string} id - The Railcontent ID of the course
 * @returns {Promise&lt;Object|null>} - The course information and lessons or null if not found.
 *
 * @example
 * fetchParentForDownload('course123')
 *   .then(course => console.log(course))
 *   .catch(error => console.error(error));
 */
export async function fetchParentForDownload(id) {
  const query = buildRawQuery(
    `railcontent_id == ${id}`,
    getFieldsForContentType('parent-download'),
    {
      isSingle: true,
    }
  )

  return fetchSanity(query, false)
}

/**
 * Fetch the data needed for the coach screen.
 * @param {string} id - The Railcontent ID of the coach
 *
 * @returns {Promise&lt;Object|null>} - The lessons for the instructor or null if not found.
 *
 * @example
 * fetchCoachLessons('coach123')
 *   .then(lessons => console.log(lessons))
 *   .catch(error => console.error(error));
 */
export async function fetchByReference(
  brand,
  { sortOrder = '-published_on', searchTerm = '', page = 1, limit = 20, includedFields = [] } = {}
) {
  const fieldsString = getFieldsForContentType()
  const start = (page - 1) * limit
  const end = start + limit
  const searchFilter = searchTerm ? `&amp;&amp; title match "${searchTerm}*"` : ''
  const includedFieldsFilter = includedFields.length > 0 ? includedFields.join(' &amp;&amp; ') : ''

  const filter = `brand == '${brand}' ${searchFilter} &amp;&amp; references(*[${includedFieldsFilter}]._id)`
  const filterWithRestrictions = await new FilterBuilder(filter).buildFilter()
  const query = buildEntityAndTotalQuery(filterWithRestrictions, fieldsString, {
    sortOrder: getSortOrder(sortOrder, brand),
    start: start,
    end: end,
  })
  return fetchSanity(query, true)
}

/**
 * Fetch the artist's lessons.
 * @param {string} brand - The brand for which to fetch lessons.
 * @param {string} name - The name of the artist
 * @param {string} contentType - The type of the lessons we need to get from the artist. If not defined, groq will get lessons from all content types
 * @param {Object} params - Parameters for sorting, searching, pagination and filtering.
 * @param {string} [params.sort="-published_on"] - The field to sort the lessons by.
 * @param {string} [params.searchTerm=""] - The search term to filter the lessons.
 * @param {number} [params.page=1] - The page number for pagination.
 * @param {number} [params.limit=10] - The number of items per page.
 * @param {Array&lt;string>} [params.includedFields=[]] - Additional filters to apply to the query in the format of a key,value array. eg. ['difficulty,Intermediate', 'genre,rock'].
 * @param {Array&lt;number>} [params.progressIds] - The ids of the lessons that are in progress or completed
 * @returns {Promise&lt;Object|null>} - The lessons for the artist and some details about the artist (name and thumbnail).
 *
 * @example
 * fetchArtistLessons('drumeo', '10 Years', 'song', {'-published_on', '', 1, 10, ["difficulty,Intermediate"], [232168, 232824, 303375, 232194, 393125]})
 *   .then(lessons => console.log(lessons))
 *   .catch(error => console.error(error));
 */
export async function fetchArtistLessons(
  brand,
  name,
  contentType,
  {
    sort = '-published_on',
    searchTerm = '',
    page = 1,
    limit = 10,
    includedFields = [],
    progressIds = undefined,
  } = {}
) {
  const fieldsString = DEFAULT_FIELDS.join(',')
  const start = (page - 1) * limit
  const end = start + limit
  const searchFilter = searchTerm ? `&amp;&amp; title match "${searchTerm}*"` : ''
  const sortOrder = getSortOrder(sort, brand)
  const addType =
    contentType &amp;&amp; Array.isArray(contentType)
      ? `_type in ['${contentType.join("', '")}'] &amp;&amp;`
      : contentType
        ? `_type == '${contentType}' &amp;&amp; `
        : ''
  const includedFieldsFilter = includedFields.length > 0 ? filtersToGroq(includedFields) : ''

  // limits the results to supplied progressIds for started &amp; completed filters
  const progressFilter =
    progressIds !== undefined ? `&amp;&amp; railcontent_id in [${progressIds.join(',')}]` : ''
  const now = getSanityDate(new Date())
  const query = `{
    "entity":
      *[_type == 'artist' &amp;&amp; name == '${name}']
        {'type': _type, name, 'thumbnail':thumbnail_url.asset->url,
        'lessons_count': count(*[${addType} brand == '${brand}' &amp;&amp; references(^._id)]),
        'lessons': *[${addType} brand == '${brand}' &amp;&amp; references(^._id) &amp;&amp; (status in ['published'] || (status == 'scheduled' &amp;&amp; defined(published_on) &amp;&amp; published_on >= '${now}')) ${searchFilter} ${includedFieldsFilter} ${progressFilter}]{${fieldsString}}
      [${start}...${end}]}
      |order(${sortOrder})f
  }`
  return fetchSanity(query, true)
}

/**
 * Fetch the genre's lessons.
 * @param {string} brand - The brand for which to fetch lessons.
 * @param {string} name - The name of the genre
 * @param {Object} params - Parameters for sorting, searching, pagination and filtering.
 * @param {string} [params.sort="-published_on"] - The field to sort the lessons by.
 * @param {string} [params.searchTerm=""] - The search term to filter the lessons.
 * @param {number} [params.page=1] - The page number for pagination.
 * @param {number} [params.limit=10] - The number of items per page.
 * @param {Array&lt;string>} [params.includedFields=[]] - Additional filters to apply to the query in the format of a key,value array. eg. ['difficulty,Intermediate', 'genre,rock'].
 * @param {Array&lt;number>} [params.progressIds] - The ids of the lessons that are in progress or completed
 * @returns {Promise&lt;Object|null>} - The lessons for the artist and some details about the artist (name and thumbnail).
 *
 * @example
 * fetchGenreLessons('drumeo', 'Blues', 'song', {'-published_on', '', 1, 10, ["difficulty,Intermediate"], [232168, 232824, 303375, 232194, 393125]})
 *   .then(lessons => console.log(lessons))
 *   .catch(error => console.error(error));
 */
export async function fetchGenreLessons(
  brand,
  name,
  contentType,
  {
    sort = '-published_on',
    searchTerm = '',
    page = 1,
    limit = 10,
    includedFields = [],
    progressIds = undefined,
  } = {}
) {
  const fieldsString = DEFAULT_FIELDS.join(',')
  const start = (page - 1) * limit
  const end = start + limit
  const searchFilter = searchTerm ? `&amp;&amp; title match "${searchTerm}*"` : ''
  const sortOrder = getSortOrder(sort, brand)
  const addType = contentType ? `_type == '${contentType}' &amp;&amp; ` : ''
  const includedFieldsFilter = includedFields.length > 0 ? filtersToGroq(includedFields) : ''
  // limits the results to supplied progressIds for started &amp; completed filters
  const progressFilter =
    progressIds !== undefined ? `&amp;&amp; railcontent_id in [${progressIds.join(',')}]` : ''
  const now = getSanityDate(new Date())
  const query = `{
    "entity":
      *[_type == 'genre' &amp;&amp; name == '${name}']
        {'type': _type, name, 'thumbnail':thumbnail_url.asset->url,
        'lessons_count': count(*[${addType} brand == '${brand}' &amp;&amp; references(^._id)]),
        'lessons': *[${addType} brand == '${brand}' &amp;&amp; references(^._id) &amp;&amp; (status in ['published'] || (status == 'scheduled' &amp;&amp; defined(published_on) &amp;&amp; published_on >= '${now}')) ${searchFilter} ${includedFieldsFilter} ${progressFilter}]{${fieldsString}}
      [${start}...${end}]}
      |order(${sortOrder})
  }`
  return fetchSanity(query, true)
}

export async function fetchTopLevelParentId(railcontentId) {
  const statusFilter = "&amp;&amp; status in ['scheduled', 'published', 'archived', 'unlisted']"

  const query = `*[railcontent_id == ${railcontentId}]{
      railcontent_id,
      'parents': *[^._id in child[]._ref ${statusFilter}]{
        railcontent_id,
          'parents': *[^._id in child[]._ref ${statusFilter}]{
            railcontent_id,
            'parents': *[^._id in child[]._ref ${statusFilter}]{
              railcontent_id,
               'parents': *[^._id in child[]._ref ${statusFilter}]{
                  railcontent_id,
            }
          }
        }
      }
    }`
  let response = await fetchSanity(query, false, { processNeedAccess: false })
  if (!response) return null
  let currentLevel = response
  for (let i = 0; i &lt; 4; i++) {
    if (currentLevel['parents'].length > 0) {
      currentLevel = currentLevel['parents'][0]
    } else {
      return currentLevel['railcontent_id']
    }
  }
  return null
}

export async function fetchHierarchy(railcontentId) {
  let topLevelId = await fetchTopLevelParentId(railcontentId)
  const childrenFilter = await new FilterBuilder(``, { isChildrenFilter: true }).buildFilter()
  const query = `*[railcontent_id == ${topLevelId}]{
      railcontent_id,
      'assignments': assignment[]{railcontent_id},
      'children': child[${childrenFilter}]->{
        railcontent_id,
        'assignments': assignment[]{railcontent_id},
        'children': child[${childrenFilter}]->{
            railcontent_id,
            'assignments': assignment[]{railcontent_id},
            'children': child[${childrenFilter}]->{
               railcontent_id,
               'assignments': assignment[]{railcontent_id},
               'children': child[${childrenFilter}]->{
                  railcontent_id,
            }
          }
        }
      },
    }`
  let response = await fetchSanity(query, false, { processNeedAccess: false })
  if (!response) return null
  let data = {
    topLevelId: topLevelId,
    parents: {},
    children: {},
  }
  populateHierarchyLookups(response, data, null)
  return data
}

function populateHierarchyLookups(currentLevel, data, parentId) {
  let contentId = currentLevel['railcontent_id']
  let children = currentLevel['children']

  data.parents[contentId] = parentId
  if (children) {
    data.children[contentId] = children.map((child) => child['railcontent_id'])
    for (let i = 0; i &lt; children.length; i++) {
      populateHierarchyLookups(children[i], data, contentId)
    }
  } else {
    data.children[contentId] = []
  }

  let assignments = currentLevel['assignments']
  if (assignments) {
    let assignmentIds = assignments.map((assignment) => assignment['railcontent_id'])
    data.children[contentId] = (data.children[contentId] ?? []).concat(assignmentIds)
    assignmentIds.forEach((assignmentId) => {
      data.parents[assignmentId] = contentId
    })
  }
}

/**
 * Fetch data for comment mod page
 *
 * @param {array} ids - List of ids get data for
 * @returns {Promise&lt;Object|null>} - A promise that resolves to an object containing the data
 */
export async function fetchCommentModContentData(ids) {
  const idsString = ids.join(',')
  const fields = `"id": railcontent_id, "type": _type, title, "url": web_url_path, "parent": *[^._id in child[]._ref]{"id": railcontent_id, title}`
  const query = await buildQuery(
    `railcontent_id in [${idsString}]`,
    { bypassPermissions: true },
    fields,
    { end: 50 }
  )
  let data = await fetchSanity(query, true)
  let mapped = {}
  data.forEach(function (content) {
    mapped[content.id] = {
      id: content.id,
      type: content.type,
      title: content.title,
      url: content.url,
      parentTitle: content.parent[0]?.title ?? null,
    }
  })
  return mapped
}

/**
 *
 * @param {string} query - The GROQ query to execute against the Sanity API.
 * @param {boolean} isList - Whether to return an array or a single result.
 * @param {Function} [customPostProcess=null] - custom post process callback
 * @param {boolean} [processNeedAccess=true] - execute the needs_access callback
 * @returns {Promise&lt;*|null>} - A promise that resolves to the fetched data or null if an error occurs or no results are found.
 *
 * @example
 * const query = `*[_type == "song"]{title, artist->name}`;
 * fetchSanity(query, true)
 *   .then(data => console.log(data))
 *   .catch(error => console.error(error));
 */

export async function fetchSanity(
  query,
  isList,
  { customPostProcess = null, processNeedAccess = true } = {}
) {
  // Check the config object before proceeding
  if (!checkSanityConfig(globalConfig)) {
    return null
  }

  const perspective = globalConfig.sanityConfig.perspective ?? 'published'
  const api = globalConfig.sanityConfig.useCachedAPI ? 'apicdn' : 'api'
  const url = `https://${globalConfig.sanityConfig.projectId}.${api}.sanity.io/v${globalConfig.sanityConfig.version}/data/query/${globalConfig.sanityConfig.dataset}?perspective=${perspective}`
  const headers = {
    'Content-Type': 'application/json',
  }

  try {
    const method = 'post'
    const options = {
      method,
      headers,
      body: JSON.stringify({ query: query }),
    }

    let promisesResult = await Promise.all([
      fetch(url, options),
      processNeedAccess ? fetchUserPermissions() : null,
    ])
    const response = promisesResult[0]
    const userPermissions = promisesResult[1]?.permissions
    const isAdmin = promisesResult[1]?.isAdmin

    if (!response.ok) {
      throw new Error(`Sanity API error: ${response.status} - ${response.statusText}`)
    }
    const result = await response.json()
    if (result.result) {
      let results = isList ? result.result : result.result[0]
      if (!results) {
        throw new Error('No results found')
      }
      results = processNeedAccess
        ? await needsAccessDecorator(results, userPermissions, isAdmin)
        : results
      return customPostProcess ? customPostProcess(results) : results
    } else {
      throw new Error('No results found')
    }
  } catch (error) {
    console.error('fetchSanity: Fetch error:', {error, query})
    return null
  }
}

function needsAccessDecorator(results, userPermissions, isAdmin) {
  if (globalConfig.sanityConfig.useDummyRailContentMethods) return results

  userPermissions = new Set(userPermissions)

  if (Array.isArray(results)) {
    results.forEach((result) => {
      result['need_access'] = doesUserNeedAccessToContent(result, userPermissions, isAdmin)
    })
  } else if (results.entity &amp;&amp; Array.isArray(results.entity)) {
    // Group By
    results.entity.forEach((result) => {
      if (result.lessons) {
        result.lessons.forEach((lesson) => {
          lesson['need_access'] = doesUserNeedAccessToContent(lesson, userPermissions, isAdmin) // Updated to check lesson access
        })
      } else {
        result['need_access'] = doesUserNeedAccessToContent(result, userPermissions, isAdmin)
      }
    })
  } else if (results.related_lessons &amp;&amp; Array.isArray(results.related_lessons)) {
    results.related_lessons.forEach((result) => {
      result['need_access'] = doesUserNeedAccessToContent(result, userPermissions, isAdmin)
    })
  } else {
    results['need_access'] = doesUserNeedAccessToContent(results, userPermissions, isAdmin)
  }

  return results
}

function doesUserNeedAccessToContent(result, userPermissions, isAdmin) {
  if (isAdmin ?? false) {
    return false
  }
  const permissions = new Set(result?.permission_id ?? [])
  if (permissions.size === 0) {
    return false
  }
  for (let permission of permissions) {
    if (userPermissions.has(permission)) {
      return false
    }
  }
  return true
}

/**
 * Fetch shows data for a brand.
 *
 * @param brand - The brand for which to fetch shows.
 * @returns {Promise&lt;{name, description, type: *, thumbnailUrl}>}
 *
 *  @example
 *
 * fetchShowsData('drumeo')
 *   .then(data => console.log(data))
 *   .catch(error => console.error(error));
 */
export async function fetchShowsData(brand) {
  let shows = showsTypes[brand] ?? []
  const showsInfo = []

  shows.forEach((type) => {
    const processedData = processMetadata(brand, type)
    if (processedData) showsInfo.push(processedData)
  })

  return showsInfo
}

/**
 * Fetch metadata from the contentMetaData.js based on brand and type.
 * For v2 you need to provide page type('lessons' or 'songs') in type parameter
 *
 * @param {string} brand - The brand for which to fetch metadata.
 * @param {string} type - The type for which to fetch metadata.
 * @returns {Promise&lt;{name, description, type: *, thumbnailUrl}>}
 *
 * @example
 *
 * fetchMetadata('drumeo','song')
 *   .then(data => console.log(data))
 *   .catch(error => console.error(error));
 */
export async function fetchMetadata(brand, type) {
  let processedData =  processMetadata(brand, type, true)
  if(processedData?.onlyAvailableTabs === true) {
    const activeTabs = await fetchRecentActivitiesActiveTabs()
    processedData.tabs = activeTabs
  }

  return processedData ? processedData : {}
}

export async function fetchChatAndLiveEnvent(brand, forcedId = null) {
  const liveEvent =
    forcedId !== null ? await fetchByRailContentIds([forcedId]) : [await fetchLiveEvent(brand)]
  if (liveEvent.length === 0 || (liveEvent.length === 1 &amp;&amp; liveEvent[0] === undefined)) {
    return null
  }
  let url = `/content/live-chat?brand=${brand}`
  const chatData = await fetchHandler(url)
  const mergedData = { ...chatData, ...liveEvent[0] }
  return mergedData
}

//Helper Functions
function arrayJoinWithQuotes(array, delimiter = ',') {
  const wrapped = array.map((value) => `'${value}'`)
  return wrapped.join(delimiter)
}

function getSanityDate(date, roundToHourForCaching = true) {
  if (roundToHourForCaching) {
    // We need to set the published on filter date to be a round time so that it doesn't bypass the query cache
    // with every request by changing the filter date every second. I've set it to one minute past the current hour
    // because publishing usually publishes content on the hour exactly which means it should still skip the cache
    // when the new content is available.
    // Round to the start of the current hour
    const roundedDate = new Date(
      date.getFullYear(),
      date.getMonth(),
      date.getDate(),
      date.getHours()
    )

    return roundedDate.toISOString()
  }

  return date.toISOString()
}

function getDateOnly(date = new Date()) {
  return date.toISOString().split('T')[0]
}

const merge = (a, b, predicate = (a, b) => a === b) => {
  const c = [...a] // copy to avoid side effects
  // add all items from B to copy C if they're not already present
  b.forEach((bItem) => (c.some((cItem) => predicate(bItem, cItem)) ? null : c.push(bItem)))
  return c
}

function checkSanityConfig(config) {
  if (!config.sanityConfig.token) {
    console.warn('fetchSanity: The "token" property is missing in the config object.')
    return false
  }
  if (!config.sanityConfig.projectId) {
    console.warn('fetchSanity: The "projectId" property is missing in the config object.')
    return false
  }
  if (!config.sanityConfig.dataset) {
    console.warn('fetchSanity: The "dataset" property is missing in the config object.')
    return false
  }
  if (!config.sanityConfig.version) {
    console.warn('fetchSanity: The "version" property is missing in the config object.')
    return false
  }
  return true
}

function buildRawQuery(
  filter = '',
  fields = '...',
  { sortOrder = 'published_on desc', start = 0, end = 10, isSingle = false }
) {
  const sortString = sortOrder ? `order(${sortOrder})` : ''
  const countString = isSingle ? '[0...1]' : `[${start}...${end}]`
  const query = `*[${filter}]{
        ${fields}
    } | ${sortString}${countString}`
  return query
}

async function buildQuery(
  baseFilter = '',
  filterParams = { pullFutureContent: false },
  fields = '...',
  { sortOrder = 'published_on desc', start = 0, end = 10, isSingle = false }
) {
  const filter = await new FilterBuilder(baseFilter, filterParams).buildFilter()
  return buildRawQuery(filter, fields, { sortOrder, start, end, isSingle })
}

function buildEntityAndTotalQuery(
  filter = '',
  fields = '...',
  { sortOrder = 'published_on desc', start = 0, end = 10, isSingle = false }
) {
  const sortString = sortOrder ? ` | order(${sortOrder})` : ''
  const countString = isSingle ? '[0...1]' : `[${start}...${end}]`
  const query = `{
      "entity": *[${filter}]  ${sortString}${countString}
      {
        ${fields}
      },
      "total": 0
    }`
  return query
}

function getFilterOptions(option, commonFilter, contentType, brand) {
  let filterGroq = ''
  const types = Array.from(new Set([...coachLessonsTypes, ...showsTypes[brand]]))

  switch (option) {
    case 'difficulty':
      filterGroq = `
                "difficulty": [
        {"type": "All", "count": count(*[${commonFilter} &amp;&amp; difficulty_string == "All"])},
        {"type": "Introductory", "count": count(*[${commonFilter} &amp;&amp; (difficulty_string == "Novice" || difficulty_string == "Introductory")])},
        {"type": "Beginner", "count": count(*[${commonFilter} &amp;&amp; difficulty_string == "Beginner"])},
        {"type": "Intermediate", "count": count(*[${commonFilter} &amp;&amp; difficulty_string == "Intermediate" ])},
        {"type": "Advanced", "count": count(*[${commonFilter} &amp;&amp; difficulty_string == "Advanced" ])},
        {"type": "Expert", "count": count(*[${commonFilter} &amp;&amp; difficulty_string == "Expert" ])}
        ][count > 0],`
      break
    case 'type':
      const typesString = types
        .map((t) => {
          return `{"type": "${t}"}`
        })
        .join(', ')
      filterGroq = `"type": [${typesString}]{type, 'count': count(*[_type == ^.type &amp;&amp; ${commonFilter}])}[count > 0],`
      break
    case 'genre':
    case 'essential':
    case 'focus':
    case 'theory':
    case 'topic':
    case 'lifestyle':
    case 'creativity':
      filterGroq = `
            "${option}": *[_type == '${option}' ${contentType ? ` &amp;&amp; '${contentType}' in filter_types` : ''} ] {
            "type": name,
                "count": count(*[${commonFilter} &amp;&amp; references(^._id)])
        }[count > 0],`
      break
    case 'instrumentless':
      filterGroq = `
            "${option}":  [
                  {"type": "Full Song Only", "count": count(*[${commonFilter} &amp;&amp; instrumentless == false ])},
                  {"type": "Instrument Removed", "count": count(*[${commonFilter} &amp;&amp; instrumentless == true ])}
              ][count > 0],`
      break
    case 'gear':
      filterGroq = `
            "${option}":  [
                  {"type": "Practice Pad", "count": count(*[${commonFilter} &amp;&amp; gear match 'Practice Pad' ])},
                  {"type": "Drum-Set", "count": count(*[${commonFilter} &amp;&amp; gear match 'Drum-Set'])}
              ][count > 0],`
      break
    case 'bpm':
      filterGroq = `
            "${option}":  [
                  {"type": "50-90", "count": count(*[${commonFilter} &amp;&amp; bpm > 50 &amp;&amp; bpm &lt; 91])},
                  {"type": "91-120", "count": count(*[${commonFilter} &amp;&amp; bpm > 90 &amp;&amp; bpm &lt; 121])},
                  {"type": "121-150", "count": count(*[${commonFilter} &amp;&amp; bpm > 120 &amp;&amp; bpm &lt; 151])},
                  {"type": "151-180", "count": count(*[${commonFilter} &amp;&amp; bpm > 150 &amp;&amp; bpm &lt; 181])},
                  {"type": "180+", "count": count(*[${commonFilter} &amp;&amp; bpm > 180])},
              ][count > 0],`
      break
    default:
      filterGroq = ''
      break
  }

  return filterGroq
}

function cleanUpGroq(query) {
  // Split the query into clauses based on the logical operators
  const clauses = query.split(/(\s*&amp;&amp;|\s*\|\|)/).map((clause) => clause.trim())

  // Filter out empty clauses
  const filteredClauses = clauses.filter((clause) => clause.length > 0)

  // Check if there are valid conditions in the clauses
  const hasConditions = filteredClauses.some((clause) => !clause.match(/^\s*&amp;&amp;\s*|\s*\|\|\s*$/))

  if (!hasConditions) {
    // If no valid conditions, return an empty string or the original query
    return ''
  }

  // Remove occurrences of '&amp;&amp; ()'
  const cleanedQuery = filteredClauses
    .join(' ')
    .replace(/&amp;&amp;\s*\(\)/g, '')
    .replace(/(\s*&amp;&amp;|\s*\|\|)(?=\s*[\s()]*$|(?=\s*&amp;&amp;|\s*\|\|))/g, '')
    .trim()

  return cleanedQuery
}

// V2 methods

export async function fetchTabData(
  brand,
  pageName,
  {
    page = 1,
    limit = 10,
    sort = '-published_on',
    includedFields = []
  } = {}
) {
  const start = (page - 1) * limit
  const end = start + limit
  // Construct the included fields filter, replacing 'difficulty' with 'difficulty_string'
  const includedFieldsFilter =
    includedFields.length > 0 ? filtersToGroq(includedFields, [], pageName) : ''

  let sortOrder = getSortOrder(sort, brand, '')

  const fieldsString = getFieldsForContentType('tab-data');
  const now = getSanityDate(new Date())

  // Determine the group by clause
  let query = ''
  let entityFieldsString = ''
  let filter = ''

  filter = `brand == "${brand}" ${includedFieldsFilter}`
  const childrenFilter = await new FilterBuilder(``, { isChildrenFilter: true, pullFutureContent: true }).buildFilter()
  const childrenFields = await getChildFieldsForContentType('tab-data')
  const lessonCountFilter = await new FilterBuilder(`_id in ^.child[]._ref`).buildFilter()
  entityFieldsString =
    ` ${fieldsString}
    'children': child[${childrenFilter}]->{ ${childrenFields} 'children': child[${childrenFilter}]->{ ${childrenFields} }, },
    'isLive': live_event_start_time &lt;= "${now}" &amp;&amp; live_event_end_time >= "${now}",
    'lesson_count': coalesce(count(*[${lessonCountFilter}]), 0),
    'length_in_seconds': coalesce(
      math::sum(
        select(
          child[${childrenFilter}]->length_in_seconds
        )
      ),
      length_in_seconds
    ),`
  const filterWithRestrictions = await new FilterBuilder(filter, {}).buildFilter()
  query = buildEntityAndTotalQuery(filterWithRestrictions, entityFieldsString, {
    sortOrder: sortOrder,
    start: start,
    end: end
  })

  let results = await fetchSanity(query, true);

  return results;
}

export async function fetchScheduledAndNewReleases(
  brand,
  { page = 1, limit = 20, sort = '-published_on' } = {}
) {
  const upcomingTypes = getUpcomingEventsTypes(brand)
  const newTypes = getNewReleasesTypes(brand)

  const scheduledTypes = merge(upcomingTypes, newTypes)
  const typesString = arrayJoinWithQuotes(scheduledTypes)
  const now = getSanityDate(new Date())

  const start = (page - 1) * limit
  const end = start + limit
  const sortOrder = getSortOrder(sort, brand)

  const query = `
    *[_type in [${typesString}] &amp;&amp; brand == '${brand}' &amp;&amp; ((status in ['published','scheduled'] &amp;&amp; published_on > '${now}')||(show_in_new_feed == true)) ]
    [${start}...${end}]
   | order(published_on asc) {
      "id": railcontent_id,
      title,
      "image": thumbnail.asset->url,
      "thumbnail": thumbnail.asset->url,
      ${artistOrInstructorName()},
      "artists": instructor[]->name,
      difficulty,
      difficulty_string,
      length_in_seconds,
      published_on,
      "type": _type,
      show_in_new_feed,
      "permission_id": permission[]->railcontent_id,
      "isLive": live_event_start_time &lt;= '${now}' &amp;&amp; live_event_end_time >= '${now}',
  }`

  return fetchSanity(query, true)
}

export async function fetchShows(brand, type, sort = 'sort') {
  const sortOrder = getSortOrder(sort, brand)
  const filter = `_type == '${type}'  &amp;&amp; brand == '${brand}'`
  const filterParams = {}

  const query = await buildQuery(filter, filterParams, getFieldsForContentType(type), {
    sortOrder: sortOrder,
    end: 100, // Adrian: added for homepage progress rows, this should be handled gracefully
  })
  return fetchSanity(query, true)
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.3</a> on Thu Sep 18 2025 15:06:36 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
