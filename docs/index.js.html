<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>index.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading"><a href="global.html">Globals</a></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#fetchAll">fetchAll</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#fetchAllFilterOptions">fetchAllFilterOptions</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#fetchAllSongs">fetchAllSongs</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#fetchArtists">fetchArtists</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#fetchByRailContentId">fetchByRailContentId</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#fetchByRailContentIds">fetchByRailContentIds</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#fetchChildren">fetchChildren</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#fetchLessonContent">fetchLessonContent</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#fetchMethodChildren">fetchMethodChildren</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#fetchMethodNextLesson">fetchMethodNextLesson</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#fetchNewReleases">fetchNewReleases</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#fetchNextPreviousLesson">fetchNextPreviousLesson</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#fetchPackAll">fetchPackAll</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#fetchPackChildren">fetchPackChildren</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#fetchRelatedLessons">fetchRelatedLessons</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#fetchRelatedSongs">fetchRelatedSongs</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#fetchSanity">fetchSanity</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#fetchSongArtistCount">fetchSongArtistCount</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#fetchSongById">fetchSongById</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#fetchSongCount">fetchSongCount</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#fetchSongFilterOptions">fetchSongFilterOptions</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#fetchUpcomingEvents">fetchUpcomingEvents</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#fetchWorkouts">fetchWorkouts</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#initializeSanityService">initializeSanityService</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">index.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>let globalConfig = {};

/**
 * Initializes the Sanity service with the given configuration.
 * This function must be called before using any other functions in this library.
 *
 * @param {Object} config - Configuration object containing Sanity API settings.
 * @param {string} config.token - The API token for authenticating with Sanity.
 * @param {string} config.projectId - The project ID in Sanity.
 * @param {string} config.dataset - The dataset name in Sanity.
 * @param {string} config.version - The API version to use.
 * @param {boolean} [config.debug=false] - Optional flag to enable debug mode, which logs the query and results.
 * @param {boolean} [config.useCachedAPI=true] - Optional flag to disable cached API. *
 * @example
 * // Initialize the Sanity service in your app.js
 * initializeSanityService({
 *   token: 'your-sanity-api-token',
 *   projectId: 'your-sanity-project-id',
 *   dataset: 'your-dataset-name',
 *   version: '2021-06-07',
 *   debug: true // Optional: Enable debug mode
 *   useCachedAPI: true // Optional: Use cached API
 * });
 */
function initializeSanityService(config) {
    globalConfig = config;
}

/**
 * Fetch a song by its document ID from Sanity.
 * @param {string} documentId - The ID of the document to fetch.
 * @returns {Promise&lt;Object|null>} - The fetched song data or null if not found.
 */
async function fetchSongById(documentId) {
    const fields = [
        'title',
        '"thumbnail_url": thumbnail.asset->url',
        '"style": genre[0]->name',
        '"artist": artist->name',
        'album',
        'instrumentless',
        'soundslice',
        'railcontent_id',
        '"resources": resource[]{resource_url, resource_name}',
    ];

    const query = `
    *[_type == "song" &amp;&amp; railcontent_id == ${documentId}]{
      ${fields.join(', ')}
    }`;
    return fetchSanity(query, false);
}

/**
 * Fetch all artists with lessons available for a specific brand.
 * @param {string} brand - The brand for which to fetch artists.
 * @returns {Promise&lt;Object|null>} - The fetched artist data or null if not found.
 */
async function fetchArtists(brand) {
    const query = `
    *[_type == "artist"]{
      name,
      "lessonsCount": count(*[_type == "song" &amp;&amp; brand == "${brand}" &amp;&amp; references(^._id)])
    }[lessonsCount > 0]`;
    return fetchSanity(query, true);
}

/**
 * Fetch current number of artists for songs within a brand.
 * @param {string} brand - The current brand.
 * @returns {Promise&lt;int|null>} - The fetched count of artists.
 */
async function fetchSongArtistCount(brand) {
    const query = `count(*[_type == 'artist']{'lessonsCount': count(*[_type == 'song' &amp;&amp; brand == '${brand}' &amp;&amp; references(^._id)]._id)}[lessonsCount > 0])`;
    return fetchSanity(query, false);
}

/**
 * Fetch related songs for a specific brand and song ID.
 * @param {string} brand - The brand for which to fetch related songs.
 * @param {string} songId - The ID of the song to find related songs for.
 * @returns {Promise&lt;Object|null>} - The fetched related songs data or null if not found.
 */
async function fetchRelatedSongs(brand, songId) {
    const query = `
    *[_type == "song" &amp;&amp; railcontent_id == ${songId}]{
      "data": array::unique([
          ...(*[_type == "song" &amp;&amp; brand == "${brand}" &amp;&amp; railcontent_id != ${songId} &amp;&amp; references(^.artist->_id)]{
          "type": _type,
          "id": railcontent_id,
          "url": web_url_path,
          "published_on": published_on,
          status,
          "fields": [
            {
              "key": "title",
              "value": title
            },
            {
              "key": "artist",
              "value": artist->name
            },
            {
              "key": "difficulty",
              "value": difficulty
            },
            {
              "key": "length_in_seconds",
              "value": soundslice[0].soundslice_length_in_second
            }
          ],
          "data": [{
            "key": "thumbnail_url",
            "value": thumbnail.asset->url
          }]
        }[0...10]),
          ...(*[_type == "song" &amp;&amp; brand == "${brand}" &amp;&amp; railcontent_id != ${songId} &amp;&amp; references(^.genre[]->_id)]{
          "type": _type,
          "id": railcontent_id,
          "url": web_url_path,
          "published_on": published_on,
          status,
          "fields": [
            {
              "key": "title",
              "value": title
            },
            {
              "key": "artist",
              "value": artist->name
            },
            {
              "key": "difficulty",
              "value": difficulty
            },
            {
              "key": "length_in_seconds",
              "value": soundslice[0].soundslice_length_in_second
            }
          ],
          "data": [{
            "key": "thumbnail_url",
            "value": thumbnail.asset->url
          }]
        }[0...10])
      ])[0...10]
    }`;

    return fetchSanity(query, true);
}

/**
 * Fetch all songs for a specific brand with pagination and search options.
 * @param {string} brand - The brand for which to fetch songs.
 * @param {Object} params - Parameters for pagination, filtering, and sorting.
 * @param {number} [params.page=1] - The page number for pagination.
 * @param {number} [params.limit=10] - The number of songs per page.
 * @param {string} [params.searchTerm=""] - The search term to filter songs by title or artist.
 * @param {string} [params.sort="-published_on"] - The field to sort the songs by.
 * @param {Array&lt;string>} [params.includedFields=[]] - The fields to include in the query.
 * @param {string} [params.groupBy=""] - The field to group the results by.
 * @returns {Promise&lt;Object|null>} - The fetched song data or null if not found.
 */
async function fetchAllSongs(brand, {
    page = 1,
    limit = 10,
    searchTerm = "",
    sort = "-published_on",
    includedFields = [],
    groupBy = ""
}) {
    console.log('groupBy', groupBy)
    const start = (page - 1) * limit;
    const end = start + limit;

    // Construct the search filter
    const searchFilter = searchTerm
        ? `&amp;&amp; (artist->name match "${searchTerm}*" || title match "${searchTerm}*")`
        : "";

    // Construct the included fields filter, replacing 'difficulty' with 'difficulty_string'
    const includedFieldsFilter = includedFields.length > 0
        ? includedFields.map(field => {
            let [key, value] = field.split(',');
            if (key === 'difficulty') {
                key = 'difficulty_string';
            }
            return `&amp;&amp; ${key} == "${value}"`;
        }).join(' ')
        : "";

    // Determine the sort order
    let sortOrder;
    switch (sort) {
        case "slug":
            sortOrder = "artist->name asc";
            break;
        case "published_on":
            sortOrder = "published_on desc";
            break;
        case "-published_on":
            sortOrder = "published_on asc";
            break;
        case "-slug":
            sortOrder = "artist->name desc";
            break;
        case "-popularity":
            sortOrder = "popularity desc";
            break;
        default:
            sortOrder = "published_on asc";
            break;
    }

    // Determine the group by clause
    let query = "";
    if (groupBy === "artist") {
        query = `
      {
        "total": count(*[_type == 'artist' &amp;&amp; count(*[_type == 'song' &amp;&amp; brand == '${brand}' &amp;&amp; ^._id == artist._ref ]._id) > 0]),
        "entity": *[_type == 'artist' &amp;&amp; count(*[_type == 'song' &amp;&amp; brand == '${brand}' &amp;&amp; ^._id == artist._ref ]._id) > 0]
          {
            'id': _id,
            'type': _type,
            name,
            'head_shot_picture_url': thumbnail_url.asset->url,
            'all_lessons_count': count(*[_type == 'song' &amp;&amp; brand == '${brand}' &amp;&amp; ^._id == artist._ref ]._id),
            'lessons': *[_type == 'song' &amp;&amp; brand == '${brand}' &amp;&amp; ^._id == artist._ref ]{
              railcontent_id,
              title,
              "image": thumbnail.asset->url,
              "artist_name": artist->name,
              artist,
              difficulty,
              difficulty_string,
              web_url_path,
              published_on
            }[0...10]
          }
        |order(${sortOrder})
        [${start}...${end}]
      }`;
    } else if (groupBy === "genre") {
        query = `
      {
        "total": count(*[_type == 'genre'  &amp;&amp; count(*[_type == 'song' &amp;&amp; brand == '${brand}' &amp;&amp; ^._id in genre[]._ref ]._id) > 0]),
        "entity":
          *[_type == 'genre'  &amp;&amp; count(*[_type == 'song' &amp;&amp; brand == '${brand}' &amp;&amp; ^._id in genre[]._ref ]._id)>0]
          {
            'id': _id,
            'type': _type,
            name,
            'head_shot_picture_url': thumbnail_url.asset->url,
            'all_lessons_count': count(*[_type == 'song' &amp;&amp; brand == '${brand}' &amp;&amp; ^._id in genre[]._ref ]._id),
            'lessons': *[_type == 'song' &amp;&amp; brand == '${brand}' &amp;&amp; ^._id in genre[]._ref ]{
              railcontent_id,
              title,
              "image": thumbnail.asset->url,
              "artist_name": artist->name,
              artist,
              difficulty,
              difficulty_string,
              web_url_path,
              published_on
            }[0...10]
          }
        |order(${sortOrder})
        [${start}...${end}]
      }`;
    } else {
        query = `
      {
        "entity": *[_type == 'song' &amp;&amp; brand == "${brand}" ${searchFilter} ${includedFieldsFilter}] | order(${sortOrder}) [${start}...${end}] {
          railcontent_id,
          title,
          "image": thumbnail.asset->url,
          "artist_name": artist->name,
          artist,
          difficulty,
          difficulty_string,
          web_url_path,
          published_on
        },
        "total": count(*[_type == 'song' &amp;&amp; brand == "${brand}" ${searchFilter} ${includedFieldsFilter}])
      }
    `;
    }

    return fetchSanity(query, false);
}

/**
 * Fetch filter options for a specific brand.
 * @param {string} brand - The brand for which to fetch filter options.
 * @returns {Promise&lt;Object|null>} - The fetched filter options or null if not found.
 */
async function fetchSongFilterOptions(brand) {
    const query = `
    {
      "difficulty": [
        {"type": "Introductory", "count": count(*[_type == 'song' &amp;&amp; brand == ${brand} &amp;&amp; difficulty_string == "Introductory"]._id)},
        {"type": "Beginner", "count": count(*[_type == 'song' &amp;&amp; brand == ${brand} &amp;&amp; difficulty_string == "Beginner"]._id)},
        {"type": "Intermediate", "count": count(*[_type == 'song' &amp;&amp; brand == ${brand} &amp;&amp; difficulty_string == "Intermediate"]._id)},
        {"type": "Advanced", "count": count(*[_type == 'song' &amp;&amp; brand == ${brand} &amp;&amp; difficulty_string == "Advanced"]._id)},
        {"type": "Expert", "count": count(*[_type == 'song' &amp;&amp; brand == ${brand} &amp;&amp; difficulty_string == "Expert"]._id)}
      ],
      "genre": *[_type == 'genre' &amp;&amp; 'song' in filter_types] {
        "type": name,
        "count": count(*[_type == 'song' &amp;&amp; brand == ${brand} &amp;&amp; references(^._id)]._id)
      },
      "instrumentless": [
        {"type": "Full Song Only", "count": count(*[_type == 'song' &amp;&amp; brand == ${brand} &amp;&amp; instrumentless == false]._id)},
        {"type": "Instrument Removed", "count": count(*[_type == 'song' &amp;&amp; brand == ${brand} &amp;&amp; instrumentless == true]._id)}
      ]
    }
  `;

    return fetchSanity(query, false);
}

/**
 * Fetch the total count of songs for a specific brand.
 * @param {string} brand - The brand for which to fetch the song count.
 * @returns {Promise&lt;number|null>} - The total count of songs or null if an error occurs.
 */
async function fetchSongCount(brand) {
    const query = `count(*[_type == 'song' &amp;&amp; brand == "${brand}"])`;
    return fetchSanity(query, false);
}

/**
 * Fetch the latest workouts for the home page of a specific brand.
 * @param {string} brand - The brand for which to fetch workouts.
 * @returns {Promise&lt;Object|null>} - The fetched workout data or null if not found.
 */
async function fetchWorkouts(brand) {
    const query = `*[_type == 'workout' &amp;&amp; brand == '${brand}'] [0...5] {
          railcontent_id,
          title,
          "image": thumbnail.asset->url,
          "artist_name": artist->name,
          artist,
          difficulty,
          difficulty_string,
          web_url_path,
          published_on
        } | order(published_on desc)[0...5]`
    return fetchSanity(query, true);
}

/**
 * Fetch the latest new releases for a specific brand.
 * @param {string} brand - The brand for which to fetch new releases.
 * @returns {Promise&lt;Object|null>} - The fetched new releases data or null if not found.
 */
async function fetchNewReleases(brand) {
    const newTypes = {
        'drumeo': ["drum-fest-international-2022", "spotlight", "the-history-of-electronic-drums", "backstage-secrets", "quick-tips", "question-and-answer", "student-collaborations", "live-streams", "live", "podcasts", "solos", "boot-camps", "gear-guides", "performances", "in-rhythm", "challenges", "on-the-road", "diy-drum-experiments", "rhythmic-adventures-of-captain-carson", "study-the-greats", "rhythms-from-another-planet", "tama-drums", "paiste-cymbals", "behind-the-scenes", "exploring-beats", "sonor-drums", "course", "play-along", "student-focus", "coach-stream", "learning-path-level", "unit", "quick-tips", "live", "question-and-answer", "student-review", "boot-camps", "song", "chords-and-scales", "pack", "podcasts", "workout", "challenge", "challenge-part"],
        'pianote': ["student-review", "student-reviews", "question-and-answer", "course", "play-along", "student-focus", "coach-stream", "learning-path-level", "unit", "quick-tips", "live", "question-and-answer", "student-review", "boot-camps", "song", "chords-and-scales", "pack", "podcasts", "workout", "challenge", "challenge-part"],
        'guitareo': ["student-review", "student-reviews", "question-and-answer", "archives", "recording", "course", "play-along", "student-focus", "coach-stream", "learning-path-level", "unit", "quick-tips", "live", "question-and-answer", "student-review", "boot-camps", "song", "chords-and-scales", "pack", "podcasts", "workout", "challenge", "challenge-part"],
        'singeo': ["student-review", "student-reviews", "question-and-answer", "course", "play-along", "student-focus", "coach-stream", "learning-path-level", "unit", "quick-tips", "live", "question-and-answer", "student-review", "boot-camps", "song", "chords-and-scales", "pack", "podcasts", "workout", "challenge", "challenge-part"],
        'default': ["student-review", "student-reviews", "question-and-answer", "course", "play-along", "student-focus", "coach-stream", "learning-path-level", "unit", "quick-tips", "live", "question-and-answer", "student-review", "boot-camps", "song", "chords-and-scales", "pack", "podcasts", "workout", "challenge", "challenge-part"]
    };
    const typesString = arrayJoinWithQuotes(newTypes[brand] ?? newTypes['default']);
    const query = `*[_type in [${typesString}] &amp;&amp; brand == '${brand}'] | order(releaseDate desc) [0...5] {
          railcontent_id,
          title,
          "image": thumbnail.asset->url,
          "artist_name": artist->name,
          artist,
          difficulty,
          difficulty_string,
          web_url_path,
          published_on
        } | order(published_on desc)[0...5]`
    return fetchSanity(query, true);
}

/**
 * Fetch upcoming events for a specific brand.
 * @param {string} brand - The brand for which to fetch upcoming events.
 * @returns {Promise&lt;Object|null>} - The fetched upcoming events data or null if not found.
 */
async function fetchUpcomingEvents(brand) {
    const liveTypes = {
        'drumeo': ["drum-fest-international-2022", "spotlight", "the-history-of-electronic-drums", "backstage-secrets", "quick-tips", "question-and-answer", "student-collaborations", "live-streams", "live", "podcasts", "solos", "boot-camps", "gear-guides", "performances", "in-rhythm", "challenges", "on-the-road", "diy-drum-experiments", "rhythmic-adventures-of-captain-carson", "study-the-greats", "rhythms-from-another-planet", "tama-drums", "paiste-cymbals", "behind-the-scenes", "exploring-beats", "sonor-drums", "student-focus", "coach-stream", "live", "question-and-answer", "student-review", "boot-camps", "recording", "pack-bundle-lesson"],
        'pianote': ["student-review", "student-reviews", "question-and-answer", "student-focus", "coach-stream", "live", "question-and-answer", "student-review", "boot-camps", "recording", "pack-bundle-lesson"],
        'guitareo': ["student-review", "student-reviews", "question-and-answer", "archives", "recording", "student-focus", "coach-stream", "live", "question-and-answer", "student-review", "boot-camps", "recording", "pack-bundle-lesson"],
        'singeo': ["student-review", "student-reviews", "question-and-answer", "student-focus", "coach-stream", "live", "question-and-answer", "student-review", "boot-camps", "recording", "pack-bundle-lesson"],
        'default': ["student-review", "student-reviews", "question-and-answer", "student-focus", "coach-stream", "live", "question-and-answer", "student-review", "boot-camps", "recording", "pack-bundle-lesson"]
    };
    const typesString = arrayJoinWithQuotes(liveTypes[brand] ?? liveTypes['default']);
    const now = getSanityDate(new Date());
    //TODO: status = 'scheduled'  is this handled in sanity?
    const query = `*[_type in [${typesString}] &amp;&amp; brand == '${brand}' &amp;&amp; published_on > '${now}']{
          railcontent_id,
          title,
          "image": thumbnail.asset->url,
          "artist_name": artist->name,
          artist,
          difficulty,
          difficulty_string,
          web_url_path,
          published_on
        } | order(published_on asc)[0...5]`;
    return fetchSanity(query, true);
}

/**
 * Fetch content by a specific Railcontent ID.
 * @param {string} id - The Railcontent ID of the content to fetch.
 * @returns {Promise&lt;Object|null>} - The fetched content data or null if not found.
 */
async function fetchByRailContentId(id) {
    const query = `*[railcontent_id == ${id}]{
          railcontent_id,
          title,
          "image": thumbnail.asset->url,
          "artist_name": artist->name,
          artist,
          difficulty,
          difficulty_string,
          web_url_path,
          published_on
        }`
    return fetchSanity(query, false);
}

/**
 * Fetch content by an array of Railcontent IDs.
 * @param {Array&lt;string>} ids - The array of Railcontent IDs of the content to fetch.
 * @returns {Promise&lt;Array&lt;Object>|null>} - The fetched content data or null if not found.
 */
async function fetchByRailContentIds(ids) {
    const idsString = ids.join(',');
    const query = `*[railcontent_id in [${idsString}]]{
          railcontent_id,
          title,
          "image": thumbnail.asset->url,
          "artist_name": artist->name,
          artist,
          difficulty,
          difficulty_string,
          web_url_path,
          published_on
        }`
    return fetchSanity(query, true);
}

/**
 * Fetch all content for a specific brand and type with pagination, search, and grouping options.
 * @param {string} brand - The brand for which to fetch content.
 * @param {string} type - The content type to fetch (e.g., 'song', 'artist').
 * @param {Object} params - Parameters for pagination, filtering, sorting, and grouping.
 * @param {number} [params.page=1] - The page number for pagination.
 * @param {number} [params.limit=10] - The number of items per page.
 * @param {string} [params.searchTerm=""] - The search term to filter content by title or artist.
 * @param {string} [params.sort="-published_on"] - The field to sort the content by.
 * @param {Array&lt;string>} [params.includedFields=[]] - The fields to include in the query.
 * @param {string} [params.groupBy=""] - The field to group the results by (e.g., 'artist', 'genre').
 * @returns {Promise&lt;Object|null>} - The fetched content data or null if not found.
 */
async function fetchAll(brand, type, {
    page = 1,
    limit = 10,
    searchTerm = "",
    sort = "-published_on",
    includedFields = [],
    groupBy = ""
}) {
    const start = (page - 1) * limit;
    const end = start + limit;

    // Construct the search filter
    const searchFilter = searchTerm
        ? `&amp;&amp; (artist->name match "${searchTerm}*" || title match "${searchTerm}*")`
        : "";

    // Construct the included fields filter, replacing 'difficulty' with 'difficulty_string'
    const includedFieldsFilter = includedFields.length > 0
        ? includedFields.map(field => {
            let [key, value] = field.split(',');
            if (key === 'difficulty') {
                key = 'difficulty_string';
            }
            return `&amp;&amp; ${key} == "${value}"`;
        }).join(' ')
        : "";

    // Determine the sort order
    let sortOrder;
    switch (sort) {
        case "slug":
            sortOrder = "artist->name asc";
            break;
        case "published_on":
            sortOrder = "published_on desc";
            break;
        case "-published_on":
            sortOrder = "published_on asc";
            break;
        case "-slug":
            sortOrder = "artist->name desc";
            break;
        case "-popularity":
            sortOrder = "popularity desc";
            break;
        default:
            sortOrder = "published_on asc";
            break;
    }

    // Determine the group by clause
    let query = "";
    let manyReference = true; //TODO: define whether reference is one to one or one to many
    if (groupBy !== "" &amp;&amp; !manyReference) {
        query = `
        {
            "total": count(*[_type == '${groupBy}' &amp;&amp; count(*[_type == '${type}' &amp;&amp; brand == '${brand}' &amp;&amp; ^._id == ${groupBy}._ref ]._id) > 0]),
            "entity": *[_type == '${groupBy}' &amp;&amp; count(*[_type == '${type}' &amp;&amp; brand == '${brand}' &amp;&amp; ^._id == ${groupBy}._ref ]._id) > 0]
            {
                'id': _id,
                'type': _type,
                name,
                'head_shot_picture_url': thumbnail_url.asset->url,
                'all_lessons_count': count(*[_type == '${type}' &amp;&amp; brand == '${brand}' &amp;&amp; ^._id == ${groupBy}._ref ]._id),
                'lessons': *[_type == '${type}' &amp;&amp; brand == '${brand}' &amp;&amp; ^._id == ${groupBy}._ref ]{
                railcontent_id,
                title,
                "image": thumbnail.asset->url,
                difficulty,
                difficulty_string,
                web_url_path,
                published_on,
                ${groupBy}
                }[0...10]
            }
            |order(${sortOrder})
            [${start}...${end}]
        }`;
    } else if (groupBy !== "" &amp;&amp; manyReference) {
        query = `
        {
            "total": count(*[_type == '${groupBy}' &amp;&amp; count(*[_type == '${type}' &amp;&amp; brand == '${brand}' &amp;&amp; ^._id in ${groupBy}[]._ref]._id)>0]),
            "entity": *[_type == '${groupBy}' &amp;&amp; count(*[_type == '${type}' &amp;&amp; brand == '${brand}' &amp;&amp; ^._id in ${groupBy}[]._ref]._id) > 0]
            {
                'id': _id,
                'type': _type,
                name,
                'head_shot_picture_url': thumbnail_url.asset->url,
                'all_lessons_count': count(*[_type == '${type}' &amp;&amp; brand == '${brand}' &amp;&amp; ^._id in ${groupBy}[]._ref ]._id),
                'lessons': *[_type == '${type}' &amp;&amp; brand == '${brand}' &amp;&amp; ^._id in ${groupBy}[]._ref ]{
                railcontent_id,
                title,
                "image": thumbnail.asset->url,
                difficulty,
                difficulty_string,
                web_url_path,
                published_on,
                ${groupBy}
                }[0...10]
            }
            |order(${sortOrder})
            [${start}...${end}]
        }`;
    } else {
        query = `
        {
            "entity": *[_type == '${type}' &amp;&amp; brand == "${brand}" ${searchFilter} ${includedFieldsFilter}] | order(${sortOrder}) [${start}...${end}] {
            railcontent_id,
            title,
            "image": thumbnail.asset->url,
            difficulty,
            difficulty_string,
            web_url_path,
            published_on
            },
            "total": count(*[_type == '${type}' &amp;&amp; brand == "${brand}" ${searchFilter} ${includedFieldsFilter}])
        }
    `;
    }

    return fetchSanity(query, false);
}

/**
 * Fetches all available filter options based on various criteria such as brand, filters, style, artist, content type, and search term.
 *
 * This function constructs a query to retrieve the total number of results and filter options such as difficulty, instrument type, and genre.
 * The filter options are dynamically generated based on the provided filters, style, artist, and content type.
 *
 * @param {string} brand - The brand for which to fetch the filter options.
 * @param {string} filters - Additional filters to apply to the query, typically in the format of Sanity GROQ queries.
 * @param {string} [style] - Optional style or genre to filter the results. If provided, the query will check if the style exists in the genre array.
 * @param {string} [artist] - Optional artist name to filter the results. If provided, the query will check if the artist's name matches.
 * @param {string} contentType - The content type to fetch (e.g., 'song', 'lesson').
 * @param {string} [term] - Optional search term to match against various fields such as title, album, artist name, and genre.
 *
 * @returns {Promise&lt;Object|null>} - A promise that resolves to an object containing the total results and filter options, or null if the query fails.
 *
 * @example
 * // Example usage:
 * fetchAllFilterOptions('myBrand', '', 'Rock', 'John Doe', 'song', 'Love')
 *   .then(options => console.log(options))
 *   .catch(error => console.error(error));
 */
async function fetchAllFilterOptions(
  brand,
  filters,
  style,
  artist,
  contentType,
  term
){
  const query = `
        {  
          "meta": {
            "totalResults": count(*[_type == '${contentType}' &amp;&amp; brand == "${brand}" &amp;&amp; ${style ? `'${style}' in genre[]->name` : `artist->name == '${artist}'`} ${filters}
              ${term ? `&amp;&amp; (title match "${term}" || album match "${term}" || artist->name match "${term}" || genre[]->name match "${term}")` : ''}]),
            "filterOptions": {
              "difficulty": [
                  {"type": "Introductory", "count": count(*[_type == '${contentType}' &amp;&amp; brand == '${brand}' &amp;&amp; ${style ? `'${style}' in genre[]->name` : `artist->name == '${artist}'`} &amp;&amp; difficulty_string == "Introductory" ${filters}])},
                  {"type": "Beginner", "count": count(*[_type == '${contentType}' &amp;&amp; brand == '${brand}' &amp;&amp; ${style ? `'${style}' in genre[]->name` : `artist->name == '${artist}'`} &amp;&amp; difficulty_string == "Beginner" ${filters}])},
                  {"type": "Intermediate", "count": count(*[_type == '${contentType}' &amp;&amp; brand == '${brand}' &amp;&amp; ${style ? `'${style}' in genre[]->name` : `artist->name == '${artist}'`} &amp;&amp; difficulty_string == "Intermediate" ${filters}])},
                  {"type": "Advanced", "count": count(*[_type == '${contentType}' &amp;&amp; brand == '${brand}' &amp;&amp; ${style ? `'${style}' in genre[]->name` : `artist->name == '${artist}'`} &amp;&amp; difficulty_string == "Advanced" ${filters}])},
                  {"type": "Expert", "count": count(*[_type == '${contentType}' &amp;&amp; brand == '${brand}' &amp;&amp; ${style ? `'${style}' in genre[]->name` : `artist->name == '${artist}'`} &amp;&amp; difficulty_string == "Expert" ${filters}])}
              ][count > 0],
              "instrumentless": [
                  {"type": "Full Song Only", "count": count(*[_type == '${contentType}' &amp;&amp; brand == '${brand}' &amp;&amp; ${style ? `'${style}' in genre[]->name` : `artist->name == '${artist}'`} &amp;&amp; instrumentless == false ${filters}])},
                  {"type": "Instrument Removed", "count": count(*[_type == '${contentType}' &amp;&amp; brand == '${brand}' &amp;&amp; ${style ? `'${style}' in genre[]->name` : `artist->name == '${artist}'`} &amp;&amp; instrumentless == true ${filters}])}
              ][count > 0],
              "genre": *[_type == 'genre' &amp;&amp; '${contentType}' in filter_types] {
                "type": name,
                "count": count(*[_type == '${contentType}' &amp;&amp; brand == "${brand}" &amp;&amp; ${style ? `'${style}' in genre[]->name` : `artist->name == '${artist}'`} &amp;&amp; references(^._id)])
              }[count > 0]
            }
          }
      }
    `;

  return fetchSanity(query, false);
}

/**
 * Fetch children content by Railcontent ID.
 * @param {string} railcontentId - The Railcontent ID of the parent content.
 * @returns {Promise&lt;Array&lt;Object>|null>} - The fetched children content data or null if not found.
 */
async function fetchChildren(railcontentId) {
    //TODO: Implement getByParentId include sum XP
    const query = `*[_railcontent_id == ${railcontentId}]{
          railcontent_id,
          title,
          "image": thumbnail.asset->url,
          "artist_name": artist->name,
          artist,
          difficulty,
          difficulty_string,
          web_url_path,
          published_on
        } | order(published_on asc)`
    return fetchSanity(query, true);
}

/**
 * Fetch the next lesson for a specific method by Railcontent ID.
 * @param {string} railcontentId - The Railcontent ID of the current lesson.
 * @returns {Promise&lt;Object|null>} - The fetched next lesson data or null if not found.
 */
async function fetchMethodNextLesson(railcontentId) {
    //TODO: Implement getNextContentForParentContentForUser
    const query = `*[_railcontent_id == ${railcontentId}]{
          railcontent_id,
          title,
          "image": thumbnail.asset->url,
          "artist_name": artist->name,
          artist,
          difficulty,
          difficulty_string,
          web_url_path,
          published_on
        }`
    return fetchSanity(query, false);
}

/**
 * Fetch all children of a specific method by Railcontent ID.
 * @param {string} railcontentId - The Railcontent ID of the method.
 * @returns {Promise&lt;Array&lt;Object>|null>} - The fetched children data or null if not found.
 */
async function fetchMethodChildren(railcontentId) {
    //TODO: Implement getByParentId include sum XP
    return fetchChildren(railcontentId);
}

/**
 * Fetch the next and previous lessons for a specific lesson by Railcontent ID.
 * @param {string} railcontentId - The Railcontent ID of the current lesson.
 * @returns {Promise&lt;Object|null>} - The fetched next and previous lesson data or null if found.
 */
async function fetchNextPreviousLesson(railcontentId) {
    //TODO: Implement getTypeNeighbouringSiblings/getNextAndPreviousLessons
    const query = `*[_railcontent_id == ${railcontentId}]{
          railcontent_id,
          title,
          "image": thumbnail.asset->url,
          "artist_name": artist->name,
          artist,
          difficulty,
          difficulty_string,
          web_url_path,
          published_on
        }`
    return fetchSanity(query, false);
}

/**
 * Fetch the page data for a specific lesson by Railcontent ID.
 * @param {string} railContentId - The Railcontent ID of the current lesson.
 * @returns {Promise&lt;Object|null>} - The fetched page data or null if found.
 */
async function fetchLessonContent(railContentId) {
    const query = `*[railcontent_id == ${railContentId} ]
            {title, published_on,"type":_type, "resources": resource, difficulty, difficulty_string, brand, soundslice, instrumentless, railcontent_id, "id":railcontent_id, slug, artist->,"thumbnail_url":thumbnail.asset->url, "url": web_url_path, soundslice_slug,description,
            "chapters": chapter[]{
              chapter_description,
              chapter_timecode,
              "chapter_thumbnail_url": chapter_thumbnail_url.asset->url
            }, 
            "coaches": instructor[]-> {
              name, 
              "id":_id,
              "coach_profile_image":thumbnail_url.asset->url
            },
            "instructors":instructor[]->name,
            instructor[]->,
            "assignments":assignment[]{
              "id": railcontent_id,
              "soundslice_slug": assignment_soundslice,
              "title": assignment_title,
              "sheet_music_image_url": assignment_sheet_music_image,
              "timecode": assignment_timecode,
              "description": assignment_description
            },
           video}`
    return fetchSanity(query, false);
}

/**
 * Fetch related lessons for a specific lesson by RailContent ID and type.
 * @param {string} railContentId - The RailContent ID of the current lesson.
 * @param {string} brand - The current brand.
 * @returns {Promise&lt;Array&lt;Object>|null>} - The fetched related lessons data or null if not found.
 */
async function fetchRelatedLessons(railContentId, brand) {
    // let sort = 'published_on'
    // if (type == 'rhythmic-adventures-of-captain-carson' ||
    //     type == 'diy-drum-experiments' ||
    //     type == 'in-rhythm') {
    //     sort = 'sort';
    // }
    //TODO: Implement $this->contentService->getFiltered
    const query = `*[railcontent_id == ${railContentId} &amp;&amp; brand == "${brand}" &amp;&amp; references(*[_type=='permission']._id)]{
                "related_lessons" : array::unique([
                  ...(*[_type=="song" &amp;&amp; brand == "${brand}" &amp;&amp; references(^.artist->_id)]{_id, "id":railcontent_id, published_on, title, "thumbnail_url":thumbnail.asset->url, difficulty_string, railcontent_id, artist->}[0...11]),
                  ...(*[_type=="song" &amp;&amp; brand == "${brand}" &amp;&amp; references(^.genre[]->_id)]{_id, "id":railcontent_id, published_on, title, "thumbnail_url":thumbnail.asset->url, difficulty_string, railcontent_id, artist->}[0...11])
                  ])|order(published_on, railcontent_id)[0...11]}`;
    return fetchSanity(query, false);
}

/**
 * Fetch all content for a specific pack by Railcontent ID.
 * @param {string} railcontentId - The Railcontent ID of the pack.
 * @returns {Promise&lt;Array&lt;Object>|null>} - The fetched pack content data or null if not found.
 */
async function fetchPackAll(railcontentId) {
    //TODO: Implement getPacks
    const query = `*[_railcontent_id == ${railcontentId}]{
          railcontent_id,
          title,
          "image": thumbnail.asset->url,
          "artist_name": artist->name,
          artist,
          difficulty,
          difficulty_string,
          web_url_path,
          published_on
        } | order(published_on asc)[0...5]`
    return fetchSanity(query, true);
}

/**
 * Fetch all children of a specific pack by Railcontent ID.
 * @param {string} railcontentId - The Railcontent ID of the pack.
 * @returns {Promise&lt;Array&lt;Object>|null>} - The fetched pack children data or null if not found.
 */
async function fetchPackChildren(railcontentId) {
    return fetchChildren(railcontentId, 'pack');
}

/**
 * Fetch data from the Sanity API based on a provided query.
 * @param {string} query - The GROQ query to execute against the Sanity API.
 * @param {boolean} isList - Whether to return an array or single result
 * @returns {Promise&lt;Object|null>} - The first result from the query, or null if an error occurs or no results are found.
 */
async function fetchSanity(query, isList) {
    // Check the config object before proceeding
    if (!checkConfig(globalConfig)) {
        return null;
    }

    if (globalConfig.debug) {
        console.log("fetchSanity Query:", query);
    }

    const encodedQuery = encodeURIComponent(query);
    const api = globalConfig.useCachedAPI ? 'apicdn' : 'api'
    const url = `https://${globalConfig.projectId}.${api}.sanity.io/v${globalConfig.version}/data/query/${globalConfig.dataset}?query=${encodedQuery}`;
    const headers = {
        'Authorization': `Bearer ${globalConfig.token}`,
        'Content-Type': 'application/json'
    };

    try {
        const response = await fetch(url, {headers});
        const result = await response.json();
        if (result.result) {
            if (globalConfig.debug) {
                console.log("fetchSanity Results:", result);
            }
            return isList ? result.result : result.result[0];
        } else {
            throw new Error('No results found');
        }
    } catch (error) {
        console.error('fetchSanity: Fetch error:', error);
        return null;
    }
}


//Helper Functions
function arrayJoinWithQuotes(array, delimiter = ',') {
    const wrapped = array.map(value => `'${value}'`);
    return wrapped.join(delimiter)
}

function getSanityDate(date) {
    return date.toISOString();
}

function checkConfig(config) {
    if (!config.token) {
        console.warn('fetchSanity: The "token" property is missing in the config object.');
        return false;
    }
    if (!config.projectId) {
        console.warn('fetchSanity: The "projectId" property is missing in the config object.');
        return false;
    }
    if (!config.dataset) {
        console.warn('fetchSanity: The "dataset" property is missing in the config object.');
        return false;
    }
    if (!config.version) {
        console.warn('fetchSanity: The "version" property is missing in the config object.');
        return false;
    }
    return true;
}


//Main
module.exports = {
    initializeSanityService,
    fetchSongById,
    fetchArtists,
    fetchSongArtistCount,
    fetchRelatedSongs,
    fetchAllSongs,
    fetchSongFilterOptions,
    fetchSongCount,
    fetchWorkouts,
    fetchNewReleases,
    fetchUpcomingEvents,
    fetchByRailContentId,
    fetchByRailContentIds,
    fetchAll,
    fetchAllFilterOptions,
    fetchMethodNextLesson,
    fetchMethodChildren,
    fetchNextPreviousLesson,
    fetchRelatedLessons,
    fetchPackAll,
    fetchPackChildren,
    fetchLessonContent
};

</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.3</a> on Mon Aug 12 2024 13:37:15 GMT+0000 (Coordinated Universal Time) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
